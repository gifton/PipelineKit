name: CI

# Full CI pipeline running all tests for every PR and push
# Expected runtime: 15-25 minutes for PRs (all tests run in parallel where possible)
# To skip expensive tests, you can close and reopen the PR with [skip ci] in commit message

on:
  push:
    branches: [ main, develop, test-ci ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/workflows/.archived/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
      - 'Examples/**/*.md'
      - 'Scripts/*.md'
      - '.swiftlint.yml'
      - '.swift-version'
      - 'codecov.yml'
      - '.editorconfig'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/workflows/.archived/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
      - 'Examples/**/*.md'
      - 'Scripts/*.md'
      - '.swiftlint.yml'
      - '.swift-version'
      - 'codecov.yml'
      - '.editorconfig'
  workflow_dispatch:

# Environment variables
env:
  DEVELOPER_DIR: /Applications/Xcode.app/Contents/Developer
  CI: 'true'
  MINIMUM_COVERAGE: 70  # Start with realistic threshold
  # Gradual enforcement flags (set to 'true' to enforce)
  ENFORCE_SWIFTLINT: 'false'  # Week 1: warn only
  ENFORCE_COVERAGE: 'false'   # Week 2: after baseline
  ENFORCE_PERFORMANCE: 'false' # Week 3: after optimization

# Permissions
permissions:
  contents: read
  checks: write
  pull-requests: write
  issues: write
  actions: read

# Concurrency control
concurrency:
  group: ci-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Quick validation for PRs
  quick-check:
    name: Quick Validation
    runs-on: ubuntu-latest  # Much faster queue times
    if: github.event_name == 'pull_request'
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Check PR Size
        run: |
          # Simple PR size check without complex processing
          git diff --stat origin/${{ github.base_ref }}...HEAD
          
          FILES_CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | wc -l)
          echo "üìä Files changed: $FILES_CHANGED"
          
          if [ "$FILES_CHANGED" -gt 20 ]; then
            echo "‚ö†Ô∏è Large PR detected (>20 files). Consider breaking into smaller PRs."
          fi

  # SwiftLint - early fail job
  swiftlint:
    name: SwiftLint
    runs-on: macos-26
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Install SwiftLint
        run: brew install swiftlint

      - name: Run SwiftLint
        run: |
          if which swiftlint >/dev/null; then
            swiftlint lint --strict --reporter json > swiftlint.json || true
            
            # Run SwiftLint and capture exit code
            swiftlint lint --strict || LINT_EXIT=$?
            
            # Conditional enforcement based on environment variable
            if [ "${{ env.ENFORCE_SWIFTLINT }}" = "true" ] && [ "${LINT_EXIT:-0}" -ne 0 ]; then
              echo "‚ùå SwiftLint violations found (enforcement enabled)"
              exit 1
            elif [ "${LINT_EXIT:-0}" -ne 0 ]; then
              echo "‚ö†Ô∏è SwiftLint violations found (enforcement disabled - will be enforced soon)"
            else
              echo "‚úÖ SwiftLint passed"
            fi
          else
            echo "SwiftLint not installed, skipping..."
          fi
      
      - name: Upload SwiftLint Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: swiftlint-results
          path: swiftlint.json
          if-no-files-found: ignore
          retention-days: 7

  # Main build job
  build:
    name: Build (macOS)
    runs-on: macos-26
    needs: swiftlint
    timeout-minutes: 15

    steps:
    - uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'

    - name: System Info
      run: |
        echo "## System Info" >> $GITHUB_STEP_SUMMARY
        echo "- Swift: $(swift --version | head -1)" >> $GITHUB_STEP_SUMMARY
        echo "- Xcode: $(xcodebuild -version | head -1)" >> $GITHUB_STEP_SUMMARY
        echo "- macOS: $(sw_vers -productVersion)" >> $GITHUB_STEP_SUMMARY

    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-

    - name: Build Debug
      run: swift build --configuration debug

    - name: Build Release
      run: swift build --configuration release

    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-macOS
        path: .build/release/
        retention-days: 7

  # Linux build job
  build-linux:
    name: Build (Linux)
    runs-on: ubuntu-latest
    container: swift:6.1
    needs: swiftlint
    timeout-minutes: 15
    continue-on-error: true  # Allow Linux to fail for now

    steps:
    - uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        apt-get update && apt-get install -y \
          libssl-dev \
          libcurl4-openssl-dev \
          libxml2-dev \
          tzdata \
          git \
          jq

    - name: Swift Version
      run: swift --version

    - name: Build Debug
      run: swift build --configuration debug

    - name: Build Release
      run: swift build --configuration release

  # Test job with coverage
  test:
    name: Test (macOS)
    runs-on: macos-26
    needs: [build, build-linux]
    timeout-minutes: 45  # Increased for individual target coverage collection

    steps:
    - uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'

    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-

    - name: List Test Targets
      run: |
        echo "Available test targets:"
        swift test list

    - name: Run Tests
      run: |
        echo "Starting test execution at $(date)"
        echo "Running tests with individual target coverage collection to prevent timeout..."

        # First, build the tests to separate build time from test time
        echo "Building tests..."
        swift build --build-tests

        # Create directory for profdata files
        mkdir -p .build/debug/codecov

        # Run each test target individually with coverage
        # This prevents timeout issues and allows better isolation
        set +e  # Don't exit on test failure

        TEST_TARGETS=(
          "PipelineKitTests"
          "PipelineKitCoreTests"
          "PipelineKitResilienceTests"
          "PipelineKitSecurityTests"
          "PipelineKitCacheTests"
          "PipelineKitPoolingTests"
          "PipelineKitObservabilityTests"
          # Performance tests skipped - run locally or in dedicated perf suite
          # "PipelineKitPerformanceTests"
        )

        FAILED_TARGETS=""
        PASSED_TARGETS=""
        OVERALL_EXIT_CODE=0

        for target in "${TEST_TARGETS[@]}"; do
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Running $target with coverage..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Start time: $(date)"

          # Run tests (job-level timeout handles hung tests)
          swift test --filter "$target" --enable-code-coverage || TARGET_EXIT_CODE=$?

          TARGET_EXIT_CODE=${TARGET_EXIT_CODE:-0}
          echo "End time: $(date) (exit code: $TARGET_EXIT_CODE)"

          if [ $TARGET_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ $target passed"
            PASSED_TARGETS="$PASSED_TARGETS $target"

            # Preserve the profdata file with a unique name
            if [ -f .build/debug/codecov/default.profdata ]; then
              cp .build/debug/codecov/default.profdata .build/debug/codecov/${target}.profdata
              echo "   Saved coverage data to ${target}.profdata"
            else
              echo "::warning::No profdata generated for $target"
            fi
          else
            echo "::warning::‚ùå $target failed with exit code $TARGET_EXIT_CODE"
            FAILED_TARGETS="$FAILED_TARGETS $target"
            OVERALL_EXIT_CODE=1
          fi
        done

        set -e

        # Summary
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Test Execution Summary"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

        if [ -n "$PASSED_TARGETS" ]; then
          echo "‚úÖ Passed targets:$PASSED_TARGETS"
        fi

        if [ -n "$FAILED_TARGETS" ]; then
          echo "::error::‚ùå Failed targets:$FAILED_TARGETS"
        fi

        # List generated profdata files
        echo ""
        echo "Generated profdata files:"
        ls -lh .build/debug/codecov/*.profdata 2>/dev/null || echo "No profdata files found"

        if [ $OVERALL_EXIT_CODE -eq 0 ]; then
          echo "::notice::‚úÖ All test targets passed successfully"
        else
          echo "::error::‚ùå Some test targets failed"
          echo "::warning::Check the test output above for specific failures"
        fi

        # Store exit code for later
        echo "TEST_EXIT_CODE=$OVERALL_EXIT_CODE" >> $GITHUB_ENV
    
    - name: Generate Coverage Report
      id: coverage_report
      run: |
        # Find the correct llvm-cov and llvm-profdata using xcrun on macOS
        LLVM_COV="$(xcrun --find llvm-cov)"
        LLVM_PROFDATA="$(xcrun --find llvm-profdata)"

        # Check if llvm tools were found
        if [ ! -x "$LLVM_COV" ] || [ ! -x "$LLVM_PROFDATA" ]; then
          echo "::warning::llvm-cov or llvm-profdata not found, skipping coverage report"
          echo "COVERAGE_SKIPPED=true" >> $GITHUB_ENV
          exit 0
        fi

        echo "Using llvm-cov at: $LLVM_COV"
        echo "Using llvm-profdata at: $LLVM_PROFDATA"

        # Check if we have any profdata files to merge
        PROFDATA_COUNT=$(ls -1 .build/debug/codecov/*.profdata 2>/dev/null | wc -l)

        if [ "$PROFDATA_COUNT" -eq 0 ]; then
          echo "::warning::No profdata files found, skipping coverage report"
          echo "COVERAGE_SKIPPED=true" >> $GITHUB_ENV
          exit 0
        fi

        echo "Found $PROFDATA_COUNT profdata files to merge"

        # Merge all profdata files from individual test targets
        echo "Merging coverage data from all test targets..."
        $LLVM_PROFDATA merge -sparse \
          .build/debug/codecov/*.profdata \
          -o .build/debug/codecov/merged.profdata

        echo "‚úÖ Successfully merged coverage data"
        ls -lh .build/debug/codecov/merged.profdata

        # Generate coverage report using merged profdata
        echo "Generating coverage report..."
        $LLVM_COV export \
          .build/debug/PipelineKitPackageTests.xctest/Contents/MacOS/PipelineKitPackageTests \
          -instr-profile=.build/debug/codecov/merged.profdata \
          -format=lcov > coverage.lcov

        echo "‚úÖ Generated coverage.lcov"

        # Generate human-readable coverage summary
        echo ""
        echo "Coverage Summary:"
        $LLVM_COV report \
          .build/debug/PipelineKitPackageTests.xctest/Contents/MacOS/PipelineKitPackageTests \
          -instr-profile=.build/debug/codecov/merged.profdata
    
    - name: Upload Coverage to Codecov
      uses: codecov/codecov-action@v5
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        file: ./coverage.lcov
        fail_ci_if_error: false
        verbose: true
    
    - name: Check Coverage Threshold
      id: coverage_check
      run: |
        # Skip if coverage was already skipped
        if [ "$COVERAGE_SKIPPED" = "true" ]; then
          echo "::notice::Coverage report generation was skipped"
          exit 0
        fi
        
        # Extract coverage percentage from lcov report
        if [ -f coverage.lcov ]; then
          TOTAL_LINES=$(grep -o 'LF:[0-9]*' coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
          HIT_LINES=$(grep -o 'LH:[0-9]*' coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
          
          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE=$((HIT_LINES * 100 / TOTAL_LINES))
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            
            # Check against threshold
            if [ "$COVERAGE" -lt "${{ env.MINIMUM_COVERAGE }}" ]; then
              if [ "${{ env.ENFORCE_COVERAGE }}" = "true" ]; then
                echo "‚ùå Coverage ${COVERAGE}% is below threshold of ${{ env.MINIMUM_COVERAGE }}% (enforcement enabled)"
                exit 1
              else
                echo "‚ö†Ô∏è Coverage ${COVERAGE}% is below threshold of ${{ env.MINIMUM_COVERAGE }}% (enforcement disabled - will be enforced soon)"
              fi
            else
              echo "‚úÖ Coverage ${COVERAGE}% meets threshold of ${{ env.MINIMUM_COVERAGE }}%"
            fi
          else
            echo "‚ö†Ô∏è Could not calculate coverage"
          fi
        else
          echo "‚ö†Ô∏è Coverage report not found"
        fi
    
    - name: Check Test Results
      if: always()
      run: |
        # Fail the job if tests failed earlier
        if [ "${TEST_EXIT_CODE:-0}" -ne 0 ]; then
          echo "::error::Tests failed earlier. Please fix the failing tests."
          exit ${TEST_EXIT_CODE}
        fi

  # Linux secondary build job (build-only)
  test-linux:
    name: Build (Linux - extra)
    runs-on: ubuntu-latest
    container: swift:6.1
    needs: [build, build-linux]
    timeout-minutes: 20
    continue-on-error: true  # Allow Linux to fail for now

    steps:
    - uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        apt-get update && apt-get install -y \
          libssl-dev \
          libcurl4-openssl-dev \
          libxml2-dev \
          tzdata \
          git

    - name: Build Debug
      run: swift build --configuration debug

    - name: Build Release
      run: swift build --configuration release

  # Stress/Resilience tests
  stress-test:
    name: Stress Tests
    runs-on: macos-26
    needs: swiftlint  # Don't depend on test to avoid cascade failures
    timeout-minutes: 30

    steps:
    - uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'

    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-

    - name: Run Stress Tests
      run: |
        # Run resilience tests which include stress scenarios
        swift build --build-tests

        # Run with explicit filter pattern matching test class names
        swift test --filter "PipelineKitResilienceTests" || {
          echo "Warning: Some tests may have failed or timed out"
          echo "Attempting to run individual test classes..."

          # Try running specific test classes if the full suite fails
          swift test --filter "CircuitBreakerMiddlewareTests" || true
          swift test --filter "BackPressureTests" || true
          swift test --filter "TimeoutMiddlewareTests" || true
        }

  # Performance tests
  performance:
    name: Performance Tests
    runs-on: macos-26
    needs: swiftlint  # Don't depend on build to avoid cascade failures
    timeout-minutes: 25

    steps:
    - uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'

    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-

    - name: Build Performance Tests
      run: swift build --configuration release --target PipelineKitPerformanceTests

    - name: Run Performance Tests
      run: |
        # Run XCTest performance tests in release mode
        swift test --configuration release --filter "PipelineKitPerformanceTests" || PERF_EXIT=$?

        # Conditional enforcement based on environment variable
        if [ "${{ env.ENFORCE_PERFORMANCE }}" = "true" ] && [ "${PERF_EXIT:-0}" -ne 0 ]; then
          echo "‚ùå Performance tests failed (enforcement enabled)"
          exit 1
        elif [ "${PERF_EXIT:-0}" -ne 0 ]; then
          echo "‚ö†Ô∏è Performance tests failed (enforcement disabled - will be enforced soon)"
        else
          echo "‚úÖ Performance tests passed"
        fi

    - name: Upload Performance Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: performance-test-results
        path: |
          .build/release/
        if-no-files-found: ignore
        retention-days: 7

  # Security scan
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      security-events: write

    steps:
    - uses: actions/checkout@v4

    - name: Run Trivy Security Scan
      uses: aquasecurity/trivy-action@0.33.1
      with:
        scan-type: 'fs'
        scan-ref: '.'
        severity: 'CRITICAL,HIGH'
        format: 'sarif'
        output: 'trivy-results.sarif'
        args: --config .trivy.yaml

    - name: Upload Trivy Results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Documentation generation and deployment
  documentation:
    name: Documentation
    runs-on: macos-26
    needs: swiftlint  # Don't depend on build to avoid cascade failures
    timeout-minutes: 20
    permissions:
      contents: read
      pages: write
      id-token: write

    steps:
    - uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'

    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-spm-docs-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-docs-
          ${{ runner.os }}-spm-
    
    - name: Build Documentation
      run: |
        # Build documentation for all public targets
        echo "Building documentation for PipelineKit..."
        swift package --allow-writing-to-directory ./docs \
          generate-documentation --target PipelineKit \
          --output-path ./docs \
          --disable-indexing \
          --transform-for-static-hosting

        # Also validate documentation for other public modules
        echo "Validating documentation for PipelineKitSecurity..."
        swift package generate-documentation --target PipelineKitSecurity

        echo "Validating documentation for PipelineKitCore..."
        swift package generate-documentation --target PipelineKitCore

        echo "Validating documentation for PipelineKitResilience..."
        swift package generate-documentation --target PipelineKitResilience

        echo "Validating documentation for PipelineKitCache..."
        swift package generate-documentation --target PipelineKitCache

        echo "Validating documentation for PipelineKitPooling..."
        swift package generate-documentation --target PipelineKitPooling

        echo "Validating documentation for PipelineKitObservability..."
        swift package generate-documentation --target PipelineKitObservability

    - name: Fix Documentation Filenames for Artifacts
      # Only run sanitization when we need to upload/deploy
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        # GitHub Actions artifacts don't allow certain characters in filenames
        # Swift-DocC creates DIRECTORIES with colons for methods like send(_:context:)
        # We must rename directories first (deepest first), then files
        
        if [ -d ./docs ]; then
          echo "Sanitizing documentation structure for GitHub artifacts..."
          
          # Process directories from deepest to shallowest using -depth
          # This ensures we rename child directories before their parents
          find ./docs -depth -type d | while IFS= read -r dir; do
            # Check if directory name contains problematic characters
            if echo "$dir" | grep -q '[:"<>|*?]'; then
              # Create new name by replacing problematic chars with underscores
              newdir=$(echo "$dir" | sed 's/[:"<>|*?]/_/g')
              
              # Only rename if the directory still exists and new name is different
              if [ -d "$dir" ] && [ "$dir" != "$newdir" ]; then
                echo "Renaming directory: $(basename "$dir") -> $(basename "$newdir")"
                mv "$dir" "$newdir" || echo "Warning: Could not rename $dir"
              fi
            fi
          done
          
          # Now process any files with problematic characters
          find ./docs -type f | while IFS= read -r file; do
            # Check if filename contains problematic characters
            if echo "$file" | grep -q '[:"<>|*?]'; then
              # Create new name by replacing problematic chars with underscores
              newfile=$(echo "$file" | sed 's/[:"<>|*?]/_/g')
              
              # Only rename if file still exists and new name is different
              if [ -f "$file" ] && [ "$file" != "$newfile" ]; then
                echo "Renaming file: $(basename "$file") -> $(basename "$newfile")"
                mv "$file" "$newfile" || echo "Warning: Could not rename $file"
              fi
            fi
          done
          
          echo "Documentation sanitization complete"
        else
          echo "No documentation directory found"
        fi
    
    - name: Upload Documentation Artifact
      # Only upload artifacts for main branch builds
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/upload-artifact@v4
      with:
        name: documentation
        path: docs/
        retention-days: 30
    
    - name: Setup Pages
      if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/configure-pages@v5
    
    - name: Upload to GitHub Pages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/upload-pages-artifact@v4
      with:
        path: ./docs
    
    - name: Deploy to GitHub Pages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      id: deployment
      uses: actions/deploy-pages@v4

  # Final status check
  ci-status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [build, build-linux, test, test-linux, swiftlint, stress-test, performance, security, documentation]
    if: always()
    timeout-minutes: 5
    steps:
      - name: Check Status
        run: |
          echo "## CI Status Report"
          echo ""
          echo "### Job Results:"
          echo "- Build (macOS): ${{ needs.build.result }}"
          echo "- Build (Linux): ${{ needs.build-linux.result }}"
          echo "- Test (macOS): ${{ needs.test.result }}"
          echo "- Build (Linux - extra): ${{ needs.test-linux.result }}"
          echo "- SwiftLint: ${{ needs.swiftlint.result }}"
          echo "- Stress Test: ${{ needs.stress-test.result }}"
          echo "- Performance: ${{ needs.performance.result }}"
          echo "- Security: ${{ needs.security.result }}"
          echo "- Documentation: ${{ needs.documentation.result }}"
          echo ""
          
          # Count failures
          CRITICAL_FAILURES=0
          
          # Critical jobs that must pass (excluding cancelled/skipped)
          if [ "${{ needs.build.result }}" != "success" ] && [ "${{ needs.build.result }}" != "cancelled" ] && [ "${{ needs.build.result }}" != "skipped" ]; then
            echo "‚ùå macOS build failed (critical)"
            CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
          elif [ "${{ needs.build.result }}" == "cancelled" ]; then
            echo "‚ö†Ô∏è macOS build was cancelled"
          fi
          
          if [ "${{ needs.test.result }}" != "success" ] && [ "${{ needs.test.result }}" != "cancelled" ] && [ "${{ needs.test.result }}" != "skipped" ]; then
            echo "‚ùå macOS tests failed (critical)"
            CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
          elif [ "${{ needs.test.result }}" == "cancelled" ]; then
            echo "‚ö†Ô∏è macOS tests were cancelled"
          fi
          
          if [ "${{ needs.swiftlint.result }}" != "success" ] && [ "${{ needs.swiftlint.result }}" != "cancelled" ] && [ "${{ needs.swiftlint.result }}" != "skipped" ]; then
            echo "‚ùå SwiftLint failed (critical)"
            CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
          elif [ "${{ needs.swiftlint.result }}" == "cancelled" ]; then
            echo "‚ö†Ô∏è SwiftLint was cancelled"
          fi
          
          # Linux can fail for now (experimental)
          if [ "${{ needs.build-linux.result }}" != "success" ]; then
            echo "‚ö†Ô∏è Linux build failed (non-blocking)"
          fi
          
          if [ "${{ needs.test-linux.result }}" != "success" ]; then
            echo "‚ö†Ô∏è Linux extra build failed (non-blocking)"
          fi
          
          # Check for cancelled jobs
          CANCELLED_JOBS=0
          for result in "${{ needs.build.result }}" "${{ needs.test.result }}" "${{ needs.swiftlint.result }}" "${{ needs.stress-test.result }}" "${{ needs.performance.result }}" "${{ needs.security.result }}" "${{ needs.documentation.result }}"; do
            if [ "$result" == "cancelled" ]; then
              CANCELLED_JOBS=$((CANCELLED_JOBS + 1))
            fi
          done
          
          # Exit with failure if any critical job failed
          if [ $CRITICAL_FAILURES -gt 0 ]; then
            echo ""
            echo "‚ùå CI failed with $CRITICAL_FAILURES critical failures"
            exit 1
          elif [ $CANCELLED_JOBS -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è CI completed with $CANCELLED_JOBS cancelled jobs (not a failure)"
            echo "Jobs may have been cancelled due to workflow cancellation or timeouts."
            exit 0
          else
            echo ""
            echo "‚úÖ All critical CI checks passed!"
          fi
