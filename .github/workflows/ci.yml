name: CI

# Full CI pipeline running all tests for every PR and push
# Expected runtime: 15-25 minutes for PRs (all tests run in parallel where possible)
# To skip expensive tests, you can close and reopen the PR with [skip ci] in commit message

on:
  push:
    branches: [ main, develop, test-ci ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/workflows/.archived/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
      - 'Examples/**/*.md'
      - 'Scripts/*.md'
      - '.swiftlint.yml'
      - '.swift-version'
      - 'codecov.yml'
      - '.editorconfig'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/workflows/.archived/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
      - 'Examples/**/*.md'
      - 'Scripts/*.md'
      - '.swiftlint.yml'
      - '.swift-version'
      - 'codecov.yml'
      - '.editorconfig'
  workflow_dispatch:

# Environment variables
env:
  SWIFT_VERSION: '6.1.0'
  MINIMUM_COVERAGE: 70  # Start with realistic threshold
  # Gradual enforcement flags (set to 'true' to enforce)
  ENFORCE_SWIFTLINT: 'false'  # Week 1: warn only
  ENFORCE_COVERAGE: 'false'   # Week 2: after baseline
  ENFORCE_PERFORMANCE: 'false' # Week 3: after optimization

# Permissions
permissions:
  contents: read
  checks: write
  pull-requests: write
  issues: write
  actions: read

# Concurrency control
concurrency:
  group: ci-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Quick validation for PRs
  quick-check:
    name: Quick Validation
    runs-on: ubuntu-latest  # Much faster queue times
    if: github.event_name == 'pull_request'
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Check PR Size
        run: |
          # Simple PR size check without complex processing
          git diff --stat origin/${{ github.base_ref }}...HEAD
          
          FILES_CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | wc -l)
          echo "üìä Files changed: $FILES_CHANGED"
          
          if [ "$FILES_CHANGED" -gt 20 ]; then
            echo "‚ö†Ô∏è Large PR detected (>20 files). Consider breaking into smaller PRs."
          fi

  # SwiftLint - early fail job
  swiftlint:
    name: SwiftLint
    runs-on: macos-14  # Keep on macOS for native SwiftLint
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v5
      
      - name: Run SwiftLint
        run: |
          if which swiftlint >/dev/null; then
            swiftlint lint --strict --reporter json > swiftlint.json || true
            
            # Run SwiftLint and capture exit code
            swiftlint lint --strict || LINT_EXIT=$?
            
            # Conditional enforcement based on environment variable
            if [ "${{ env.ENFORCE_SWIFTLINT }}" = "true" ] && [ "${LINT_EXIT:-0}" -ne 0 ]; then
              echo "‚ùå SwiftLint violations found (enforcement enabled)"
              exit 1
            elif [ "${LINT_EXIT:-0}" -ne 0 ]; then
              echo "‚ö†Ô∏è SwiftLint violations found (enforcement disabled - will be enforced soon)"
            else
              echo "‚úÖ SwiftLint passed"
            fi
          else
            echo "SwiftLint not installed, skipping..."
          fi
      
      - name: Upload SwiftLint Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: swiftlint-results
          path: swiftlint.json
          if-no-files-found: ignore
          retention-days: 7

  # Main build job
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: swiftlint
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        os: [macos-14]
        include:
          - os: macos-14
            platform: macOS
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup Swift (macOS)
      if: runner.os == 'macOS'
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'build'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Swift Version
      run: |
        swift --version
        if ! swift --version | grep -q "version 6.1"; then
          echo "::error::Expected Swift 6.1 toolchain after setup-swift"
          exit 1
        fi
      
    - name: Build Debug
      run: swift build --configuration debug
      
    - name: Build Release
      run: swift build --configuration release
      
    - name: Upload Build Artifacts
      if: runner.os == 'macOS'
      uses: actions/upload-artifact@v4
      with:
        name: build-${{ matrix.platform }}
        path: .build/release/
        retention-days: 7

  # Linux build job
  build-linux:
    name: Build (Linux)
    runs-on: ubuntu-latest
    container: swift:6.1
    needs: swiftlint
    timeout-minutes: 15
    continue-on-error: true  # Allow Linux to fail for now
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Install Dependencies
      run: |
        apt-get update && apt-get install -y \
          libssl-dev \
          libcurl4-openssl-dev \
          libxml2-dev \
          tzdata \
          git \
          jq
    
    - name: Swift Version
      run: swift --version
      
    - name: Build Debug
      run: swift build --configuration debug
      
    - name: Build Release
      run: swift build --configuration release

  # Test job with coverage
  test:
    name: Test (macOS)
    runs-on: macos-14
    needs: [build, build-linux]
    timeout-minutes: 20
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'test'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Run Tests
      run: |
        # Run tests without --parallel to prevent hanging
        set +e  # Don't exit on test failure
        swift test --enable-code-coverage
        TEST_EXIT_CODE=$?
        set -e
        
        # Parse test output to provide a summary
        if [ $TEST_EXIT_CODE -eq 0 ]; then
          echo "::notice::‚úÖ All tests passed successfully"
        else
          echo "::error::‚ùå Tests failed with exit code $TEST_EXIT_CODE"
          echo "::warning::Check the test output above for specific failures"
          # Continue anyway to generate coverage report
        fi
        
        # Store exit code for later
        echo "TEST_EXIT_CODE=$TEST_EXIT_CODE" >> $GITHUB_ENV
    
    - name: Generate Coverage Report
      id: coverage_report
      run: |
        # Find the correct llvm-cov using xcrun on macOS
        if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
          LLVM_COV="$(xcrun --find llvm-cov)"
        else
          # For Linux, try to get it from swift toolchain
          TOOLCHAIN_BIN=$(swift -print-target-info | jq -r '.runtimeResourcePath' | sed 's|/lib/swift$|/bin|')
          LLVM_COV="${TOOLCHAIN_BIN}/llvm-cov"
        fi
        
        # Check if llvm-cov was found
        if [ ! -x "$LLVM_COV" ]; then
          echo "::warning::llvm-cov not found, skipping coverage report"
          echo "COVERAGE_SKIPPED=true" >> $GITHUB_ENV
          exit 0
        fi
        
        echo "Using llvm-cov at: $LLVM_COV"
        
        # Generate coverage report
        $LLVM_COV export \
          .build/debug/PipelineKitPackageTests.xctest/Contents/MacOS/PipelineKitPackageTests \
          -instr-profile=.build/debug/codecov/default.profdata \
          -format=lcov > coverage.lcov
        
        # Simple coverage summary
        $LLVM_COV report \
          .build/debug/PipelineKitPackageTests.xctest/Contents/MacOS/PipelineKitPackageTests \
          -instr-profile=.build/debug/codecov/default.profdata
    
    - name: Upload Coverage to Codecov
      uses: codecov/codecov-action@v5
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        file: ./coverage.lcov
        fail_ci_if_error: false
        verbose: true
    
    - name: Check Coverage Threshold
      id: coverage_check
      run: |
        # Skip if coverage was already skipped
        if [ "$COVERAGE_SKIPPED" = "true" ]; then
          echo "::notice::Coverage report generation was skipped"
          exit 0
        fi
        
        # Extract coverage percentage from lcov report
        if [ -f coverage.lcov ]; then
          TOTAL_LINES=$(grep -o 'LF:[0-9]*' coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
          HIT_LINES=$(grep -o 'LH:[0-9]*' coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
          
          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE=$((HIT_LINES * 100 / TOTAL_LINES))
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            
            # Check against threshold
            if [ "$COVERAGE" -lt "${{ env.MINIMUM_COVERAGE }}" ]; then
              if [ "${{ env.ENFORCE_COVERAGE }}" = "true" ]; then
                echo "‚ùå Coverage ${COVERAGE}% is below threshold of ${{ env.MINIMUM_COVERAGE }}% (enforcement enabled)"
                exit 1
              else
                echo "‚ö†Ô∏è Coverage ${COVERAGE}% is below threshold of ${{ env.MINIMUM_COVERAGE }}% (enforcement disabled - will be enforced soon)"
              fi
            else
              echo "‚úÖ Coverage ${COVERAGE}% meets threshold of ${{ env.MINIMUM_COVERAGE }}%"
            fi
          else
            echo "‚ö†Ô∏è Could not calculate coverage"
          fi
        else
          echo "‚ö†Ô∏è Coverage report not found"
        fi
    
    - name: Check Test Results
      if: always()
      run: |
        # Fail the job if tests failed earlier
        if [ "${TEST_EXIT_CODE:-0}" -ne 0 ]; then
          echo "::error::Tests failed earlier. Please fix the failing tests."
          exit ${TEST_EXIT_CODE}
        fi

  # Linux secondary build job (build-only)
  test-linux:
    name: Build (Linux - extra)
    runs-on: ubuntu-latest
    container: swift:6.1
    needs: [build, build-linux]
    timeout-minutes: 20
    continue-on-error: true  # Allow Linux to fail for now
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Install Dependencies
      run: |
        apt-get update && apt-get install -y \
          libssl-dev \
          libcurl4-openssl-dev \
          libxml2-dev \
          tzdata \
          git
    
    - name: Build Debug
      run: swift build --configuration debug

    - name: Build Release
      run: swift build --configuration release

  # Stress/Resilience tests
  stress-test:
    name: Stress Tests
    runs-on: macos-14
    needs: swiftlint  # Don't depend on test to avoid cascade failures
    # Now runs on all events including PRs
    timeout-minutes: 30
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'stress'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Run Stress Tests
      run: |
        # Run resilience tests which include stress scenarios
        # Build tests first to ensure they're compiled
        swift build --build-tests
        
        # Run with explicit filter pattern matching test class names
        swift test --filter "PipelineKitResilienceTests" --disable-xctest-dynamic-overlay || {
          echo "Warning: Some tests may have failed or timed out"
          echo "Attempting to run individual test classes..."
          
          # Try running specific test classes if the full suite fails
          swift test --filter "CircuitBreakerMiddlewareTests" || true
          swift test --filter "BackPressureTests" || true
          swift test --filter "TimeoutMiddlewareTests" || true
        }

  # Performance tests
  performance:
    name: Performance Tests
    runs-on: macos-14
    needs: swiftlint  # Don't depend on build to avoid cascade failures
    # Now runs on all events including PRs
    timeout-minutes: 25
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'performance'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Build Performance Tests
      run: swift build --configuration release --target PipelineKitPerformanceTests
    
    - name: Run Performance Tests
      run: |
        # Run XCTest performance tests in release mode
        swift test --configuration release --filter "PipelineKitPerformanceTests" || PERF_EXIT=$?
        
        # Conditional enforcement based on environment variable
        if [ "${{ env.ENFORCE_PERFORMANCE }}" = "true" ] && [ "${PERF_EXIT:-0}" -ne 0 ]; then
          echo "‚ùå Performance tests failed (enforcement enabled)"
          exit 1
        elif [ "${PERF_EXIT:-0}" -ne 0 ]; then
          echo "‚ö†Ô∏è Performance tests failed (enforcement disabled - will be enforced soon)"
        else
          echo "‚úÖ Performance tests passed"
        fi
    
    - name: Upload Performance Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: performance-test-results
        path: |
          .build/release/
        if-no-files-found: ignore
        retention-days: 7

  # Security scan
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    # Now runs on all events including PRs
    timeout-minutes: 15
    permissions:
      security-events: write
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Run Trivy Security Scan
      uses: aquasecurity/trivy-action@0.33.1
      with:
        scan-type: 'fs'
        scan-ref: '.'
        severity: 'CRITICAL,HIGH'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy Results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Documentation generation and deployment
  documentation:
    name: Documentation
    runs-on: macos-14
    needs: swiftlint  # Don't depend on build to avoid cascade failures
    # Run on all events, but only deploy on main branch
    timeout-minutes: 20
    continue-on-error: true  # Don't block CI if documentation fails
    permissions:
      contents: read
      pages: write
      id-token: write
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/.swiftpm
        key: ${{ runner.os }}-spm-docs-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-docs-
          ${{ runner.os }}-spm-
    
    - name: Build Documentation
      run: |
        swift package --allow-writing-to-directory ./docs \
          generate-documentation --target PipelineKit \
          --output-path ./docs \
          --disable-indexing \
          --transform-for-static-hosting
    
    - name: Fix Documentation Filenames for Artifacts
      run: |
        # GitHub Actions artifacts don't allow certain characters in filenames
        # Swift-DocC creates DIRECTORIES with colons for methods like send(_:context:)
        # We must rename directories first (deepest first), then files
        
        if [ -d ./docs ]; then
          echo "Sanitizing documentation structure for GitHub artifacts..."
          
          # Process directories from deepest to shallowest using -depth
          # This ensures we rename child directories before their parents
          find ./docs -depth -type d | while IFS= read -r dir; do
            # Check if directory name contains problematic characters
            if echo "$dir" | grep -q '[:"<>|*?]'; then
              # Create new name by replacing problematic chars with underscores
              newdir=$(echo "$dir" | sed 's/[:"<>|*?]/_/g')
              
              # Only rename if the directory still exists and new name is different
              if [ -d "$dir" ] && [ "$dir" != "$newdir" ]; then
                echo "Renaming directory: $(basename "$dir") -> $(basename "$newdir")"
                mv "$dir" "$newdir" || echo "Warning: Could not rename $dir"
              fi
            fi
          done
          
          # Now process any files with problematic characters
          find ./docs -type f | while IFS= read -r file; do
            # Check if filename contains problematic characters
            if echo "$file" | grep -q '[:"<>|*?]'; then
              # Create new name by replacing problematic chars with underscores
              newfile=$(echo "$file" | sed 's/[:"<>|*?]/_/g')
              
              # Only rename if file still exists and new name is different
              if [ -f "$file" ] && [ "$file" != "$newfile" ]; then
                echo "Renaming file: $(basename "$file") -> $(basename "$newfile")"
                mv "$file" "$newfile" || echo "Warning: Could not rename $file"
              fi
            fi
          done
          
          echo "Documentation sanitization complete"
        else
          echo "No documentation directory found"
        fi
    
    - name: Upload Documentation Artifact
      uses: actions/upload-artifact@v4
      with:
        name: documentation
        path: docs/
        retention-days: 30
    
    - name: Setup Pages
      if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/configure-pages@v5
    
    - name: Upload to GitHub Pages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/upload-pages-artifact@v4
      with:
        path: ./docs
    
    - name: Deploy to GitHub Pages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      id: deployment
      uses: actions/deploy-pages@v4

  # Final status check
  ci-status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [build, build-linux, test, test-linux, swiftlint, stress-test, performance, security, documentation]
    if: always()
    timeout-minutes: 5
    steps:
      - name: Check Status
        run: |
          echo "## CI Status Report"
          echo ""
          echo "### Job Results:"
          echo "- Build (macOS): ${{ needs.build.result }}"
          echo "- Build (Linux): ${{ needs.build-linux.result }}"
          echo "- Test (macOS): ${{ needs.test.result }}"
          echo "- Build (Linux - extra): ${{ needs.test-linux.result }}"
          echo "- SwiftLint: ${{ needs.swiftlint.result }}"
          echo "- Stress Test: ${{ needs.stress-test.result }}"
          echo "- Performance: ${{ needs.performance.result }}"
          echo "- Security: ${{ needs.security.result }}"
          echo "- Documentation: ${{ needs.documentation.result }}"
          echo ""
          
          # Count failures
          CRITICAL_FAILURES=0
          
          # Critical jobs that must pass (excluding cancelled/skipped)
          if [ "${{ needs.build.result }}" != "success" ] && [ "${{ needs.build.result }}" != "cancelled" ] && [ "${{ needs.build.result }}" != "skipped" ]; then
            echo "‚ùå macOS build failed (critical)"
            CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
          elif [ "${{ needs.build.result }}" == "cancelled" ]; then
            echo "‚ö†Ô∏è macOS build was cancelled"
          fi
          
          if [ "${{ needs.test.result }}" != "success" ] && [ "${{ needs.test.result }}" != "cancelled" ] && [ "${{ needs.test.result }}" != "skipped" ]; then
            echo "‚ùå macOS tests failed (critical)"
            CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
          elif [ "${{ needs.test.result }}" == "cancelled" ]; then
            echo "‚ö†Ô∏è macOS tests were cancelled"
          fi
          
          if [ "${{ needs.swiftlint.result }}" != "success" ] && [ "${{ needs.swiftlint.result }}" != "cancelled" ] && [ "${{ needs.swiftlint.result }}" != "skipped" ]; then
            echo "‚ùå SwiftLint failed (critical)"
            CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
          elif [ "${{ needs.swiftlint.result }}" == "cancelled" ]; then
            echo "‚ö†Ô∏è SwiftLint was cancelled"
          fi
          
          # Linux can fail for now (experimental)
          if [ "${{ needs.build-linux.result }}" != "success" ]; then
            echo "‚ö†Ô∏è Linux build failed (non-blocking)"
          fi
          
          if [ "${{ needs.test-linux.result }}" != "success" ]; then
            echo "‚ö†Ô∏è Linux extra build failed (non-blocking)"
          fi
          
          # Check for cancelled jobs
          CANCELLED_JOBS=0
          for result in "${{ needs.build.result }}" "${{ needs.test.result }}" "${{ needs.swiftlint.result }}" "${{ needs.stress-test.result }}" "${{ needs.performance.result }}" "${{ needs.security.result }}" "${{ needs.documentation.result }}"; do
            if [ "$result" == "cancelled" ]; then
              CANCELLED_JOBS=$((CANCELLED_JOBS + 1))
            fi
          done
          
          # Exit with failure if any critical job failed
          if [ $CRITICAL_FAILURES -gt 0 ]; then
            echo ""
            echo "‚ùå CI failed with $CRITICAL_FAILURES critical failures"
            exit 1
          elif [ $CANCELLED_JOBS -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è CI completed with $CANCELLED_JOBS cancelled jobs (not a failure)"
            echo "Jobs may have been cancelled due to workflow cancellation or timeouts."
            exit 0
          else
            echo ""
            echo "‚úÖ All critical CI checks passed!"
          fi
