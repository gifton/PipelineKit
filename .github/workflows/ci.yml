name: CI

# Full CI pipeline running all tests for every PR and push
# Expected runtime: 15-25 minutes for PRs (all tests run in parallel where possible)
# To skip expensive tests, you can close and reopen the PR with [skip ci] in commit message

on:
  push:
    branches: [ main, develop, test-ci ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/workflows/.archived/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
      - 'Examples/**/*.md'
      - 'Scripts/*.md'
      - '.swiftlint.yml'
      - '.swift-version'
      - 'codecov.yml'
      - '.editorconfig'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/workflows/.archived/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
      - 'Examples/**/*.md'
      - 'Scripts/*.md'
      - '.swiftlint.yml'
      - '.swift-version'
      - 'codecov.yml'
      - '.editorconfig'
  workflow_dispatch:

# Environment variables
env:
  SWIFT_VERSION: '6.0'
  MINIMUM_COVERAGE: 70  # Start with realistic threshold
  # Gradual enforcement flags (set to 'true' to enforce)
  ENFORCE_SWIFTLINT: 'false'  # Week 1: warn only
  ENFORCE_COVERAGE: 'false'   # Week 2: after baseline
  ENFORCE_PERFORMANCE: 'false' # Week 3: after optimization

# Permissions
permissions:
  contents: read
  checks: write
  pull-requests: write
  issues: write
  actions: read

# Concurrency control
concurrency:
  group: ci-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Quick validation for PRs
  quick-check:
    name: Quick Validation
    runs-on: ubuntu-latest  # Much faster queue times
    if: github.event_name == 'pull_request'
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check PR Size
        run: |
          # Simple PR size check without complex processing
          git diff --stat origin/${{ github.base_ref }}...HEAD
          
          FILES_CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | wc -l)
          echo "üìä Files changed: $FILES_CHANGED"
          
          if [ "$FILES_CHANGED" -gt 20 ]; then
            echo "‚ö†Ô∏è Large PR detected (>20 files). Consider breaking into smaller PRs."
          fi

  # SwiftLint - early fail job
  swiftlint:
    name: SwiftLint
    runs-on: macos-14  # Keep on macOS for native SwiftLint
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      
      - name: Run SwiftLint
        run: |
          if which swiftlint >/dev/null; then
            swiftlint lint --strict --reporter json > swiftlint.json || true
            
            # Run SwiftLint and capture exit code
            swiftlint lint --strict || LINT_EXIT=$?
            
            # Conditional enforcement based on environment variable
            if [ "${{ env.ENFORCE_SWIFTLINT }}" = "true" ] && [ "${LINT_EXIT:-0}" -ne 0 ]; then
              echo "‚ùå SwiftLint violations found (enforcement enabled)"
              exit 1
            elif [ "${LINT_EXIT:-0}" -ne 0 ]; then
              echo "‚ö†Ô∏è SwiftLint violations found (enforcement disabled - will be enforced soon)"
            else
              echo "‚úÖ SwiftLint passed"
            fi
          else
            echo "SwiftLint not installed, skipping..."
          fi
      
      - name: Upload SwiftLint Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: swiftlint-results
          path: swiftlint.json
          if-no-files-found: ignore
          retention-days: 7

  # Main build job
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: swiftlint
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        os: [macos-14, ubuntu-latest]
        include:
          - os: macos-14
            platform: macOS
          - os: ubuntu-latest
            platform: Linux
            container: swift:6.0
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Swift (macOS)
      if: runner.os == 'macOS'
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'build'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Swift Version
      run: swift --version
      
    - name: Build Debug
      run: swift build --configuration debug
      
    - name: Build Release
      run: swift build --configuration release
      
    - name: Upload Build Artifacts
      if: runner.os == 'macOS'
      uses: actions/upload-artifact@v4
      with:
        name: build-${{ matrix.platform }}
        path: .build/release/
        retention-days: 7

  # Test job with coverage
  test:
    name: Test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: build
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        os: [macos-14, ubuntu-latest]
        include:
          - os: macos-14
            platform: macOS
            coverage: true
          - os: ubuntu-latest
            platform: Linux
            container: swift:6.0
            coverage: false  # Coverage collection on Linux needs different approach
    
    container: ${{ matrix.container }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Swift (macOS)
      if: runner.os == 'macOS'
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'test'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Run Tests
      run: |
        # Run tests without --parallel to prevent hanging
        swift test --enable-code-coverage
    
    - name: Generate Coverage Report (macOS)
      if: matrix.coverage && runner.os == 'macOS'
      run: |
        # Find the correct llvm-cov
        TOOLCHAIN_BIN=$(swift -print-target-info | jq -r '.runtimeResourcePath' | sed 's|/lib/swift$|/bin|')
        LLVM_COV="${TOOLCHAIN_BIN}/llvm-cov"
        
        # Generate coverage report
        $LLVM_COV export \
          .build/debug/PipelineKitPackageTests.xctest/Contents/MacOS/PipelineKitPackageTests \
          -instr-profile=.build/debug/codecov/default.profdata \
          -format=lcov > coverage.lcov
        
        # Simple coverage summary
        $LLVM_COV report \
          .build/debug/PipelineKitPackageTests.xctest/Contents/MacOS/PipelineKitPackageTests \
          -instr-profile=.build/debug/codecov/default.profdata
    
    - name: Upload Coverage to Codecov
      if: matrix.coverage && runner.os == 'macOS'
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        file: ./coverage.lcov
        fail_ci_if_error: false
        verbose: true
    
    - name: Check Coverage Threshold
      if: matrix.coverage && runner.os == 'macOS'
      id: coverage_check
      run: |
        # Extract coverage percentage from lcov report
        if [ -f coverage.lcov ]; then
          TOTAL_LINES=$(grep -o 'LF:[0-9]*' coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
          HIT_LINES=$(grep -o 'LH:[0-9]*' coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
          
          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE=$((HIT_LINES * 100 / TOTAL_LINES))
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            
            # Check against threshold
            if [ "$COVERAGE" -lt "${{ env.MINIMUM_COVERAGE }}" ]; then
              if [ "${{ env.ENFORCE_COVERAGE }}" = "true" ]; then
                echo "‚ùå Coverage ${COVERAGE}% is below threshold of ${{ env.MINIMUM_COVERAGE }}% (enforcement enabled)"
                exit 1
              else
                echo "‚ö†Ô∏è Coverage ${COVERAGE}% is below threshold of ${{ env.MINIMUM_COVERAGE }}% (enforcement disabled - will be enforced soon)"
              fi
            else
              echo "‚úÖ Coverage ${COVERAGE}% meets threshold of ${{ env.MINIMUM_COVERAGE }}%"
            fi
          else
            echo "‚ö†Ô∏è Could not calculate coverage"
          fi
        else
          echo "‚ö†Ô∏è Coverage report not found"
        fi

  # Stress/Resilience tests
  stress-test:
    name: Stress Tests
    runs-on: macos-14
    needs: test
    # Now runs on all events including PRs
    timeout-minutes: 30
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'stress'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Run Stress Tests
      run: |
        # Run resilience tests which include stress scenarios
        swift test --filter "PipelineKitResilienceTests"

  # Performance tests
  performance:
    name: Performance Tests
    runs-on: macos-14
    needs: build
    # Now runs on all events including PRs
    timeout-minutes: 25
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Setup SPM Cache
      uses: ./.github/actions/setup-spm-cache
      with:
        cache-key-prefix: 'performance'
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Build Performance Tests
      run: swift build --configuration release --target PipelineKitPerformanceTests
    
    - name: Run Performance Tests
      run: |
        # Run XCTest performance tests in release mode
        swift test --configuration release --filter "PipelineKitPerformanceTests" || PERF_EXIT=$?
        
        # Conditional enforcement based on environment variable
        if [ "${{ env.ENFORCE_PERFORMANCE }}" = "true" ] && [ "${PERF_EXIT:-0}" -ne 0 ]; then
          echo "‚ùå Performance tests failed (enforcement enabled)"
          exit 1
        elif [ "${PERF_EXIT:-0}" -ne 0 ]; then
          echo "‚ö†Ô∏è Performance tests failed (enforcement disabled - will be enforced soon)"
        else
          echo "‚úÖ Performance tests passed"
        fi
    
    - name: Upload Performance Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: performance-test-results
        path: |
          .build/release/
        if-no-files-found: ignore
        retention-days: 7

  # Security scan
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    # Now runs on all events including PRs
    timeout-minutes: 15
    permissions:
      security-events: write
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Trivy Security Scan
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        severity: 'CRITICAL,HIGH'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy Results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Documentation generation and deployment
  documentation:
    name: Documentation
    runs-on: macos-14
    needs: build
    # Run on all events, but only deploy on main branch
    timeout-minutes: 20
    permissions:
      contents: read
      pages: write
      id-token: write
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: ${{ env.SWIFT_VERSION }}
    
    - name: Cache SPM
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/.swiftpm
        key: ${{ runner.os }}-spm-docs-${{ hashFiles('Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-docs-
          ${{ runner.os }}-spm-
    
    - name: Build Documentation
      run: |
        swift package --allow-writing-to-directory ./docs \
          generate-documentation --target PipelineKit \
          --output-path ./docs \
          --disable-indexing \
          --transform-for-static-hosting
    
    - name: Upload Documentation Artifact
      uses: actions/upload-artifact@v4
      with:
        name: documentation
        path: docs/
        retention-days: 30
    
    - name: Setup Pages
      if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/configure-pages@v4
    
    - name: Upload to GitHub Pages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/upload-pages-artifact@v3
      with:
        path: ./docs
    
    - name: Deploy to GitHub Pages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      id: deployment
      uses: actions/deploy-pages@v4

  # Final status check
  ci-status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [build, test, swiftlint, stress-test, performance, security, documentation]
    if: always()
    timeout-minutes: 5
    steps:
      - name: Check Status
        run: |
          # Check all required jobs
          if [ "${{ needs.build.result }}" != "success" ] || \
             [ "${{ needs.test.result }}" != "success" ] || \
             [ "${{ needs.swiftlint.result }}" != "success" ] || \
             [ "${{ needs.stress-test.result }}" != "success" ] || \
             [ "${{ needs.performance.result }}" != "success" ] || \
             [ "${{ needs.security.result }}" != "success" ] || \
             [ "${{ needs.documentation.result }}" != "success" ]; then
            echo "‚ùå CI failed"
            echo ""
            echo "Job Results:"
            echo "- Build: ${{ needs.build.result }}"
            echo "- Test: ${{ needs.test.result }}"
            echo "- SwiftLint: ${{ needs.swiftlint.result }}"
            echo "- Stress Test: ${{ needs.stress-test.result }}"
            echo "- Performance: ${{ needs.performance.result }}"
            echo "- Security: ${{ needs.security.result }}"
            echo "- Documentation: ${{ needs.documentation.result }}"
            exit 1
          fi
          echo "‚úÖ All CI checks passed!"