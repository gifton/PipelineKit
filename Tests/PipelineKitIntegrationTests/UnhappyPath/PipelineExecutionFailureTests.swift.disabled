import XCTest
import Foundation
@testable import PipelineKitCore
import PipelineKitTestSupport

// MARK: - Test Support Types for PipelineExecutionFailureTests

struct PipelineTestCommand: Command {
    typealias Result = String
    let value: String
    
    func execute() async throws -> String {
        return "Executed: \(value)"
    }
}

struct PipelineTestHandler: CommandHandler {
    typealias CommandType = PipelineTestCommand
    
    func handle(_ command: PipelineTestCommand) async throws -> String {
        return "Handled: \(command.value)"
    }
}

/// Tests for pipeline execution failure scenarios
final class PipelineExecutionFailureTests: XCTestCase {
    // MARK: - Handler Failures
    
    func testHandlerException() async throws {
        let faultyHandler = PipelineFaultyHandler()
        let pipeline = StandardPipeline(handler: faultyHandler)
        
        let command = PipelineTestCommand(value: "trigger_error")
        let context = CommandContext.test()
        
        do {
            _ = try await pipeline.execute(command, context: context)
            XCTFail("Handler exception should propagate")
        } catch HandlerError.processingFailed {
            // Expected error
        }
    }
    
    func testHandlerTimeout() async throws {
        let slowHandler = PipelineSlowHandler()
        let pipeline = StandardPipeline(handler: slowHandler)
        
        let command = PipelineTestCommand(value: "slow_operation")
        let context = CommandContext.test()
        
        // Use timeout to simulate real-world timeout scenarios
        do {
            let result = try await withPipelineTimeout(seconds: 0.1) {
                try await pipeline.execute(command, context: context)
            }
            XCTFail("Handler should timeout, got result: \(result)")
        } catch {
            // Expected timeout
            XCTAssertTrue(error is PipelineError || error.localizedDescription.contains("timeout"))
        }
    }
    
    func testHandlerMemoryLeak() async throws {
        weak var weakHandler: PipelineLeakyHandler?
        
        autoreleasepool {
            let handler = PipelineLeakyHandler()
            weakHandler = handler
            _ = StandardPipeline(handler: handler)
        }
        
        // Handler should still exist because pipeline holds it
        XCTAssertNotNil(weakHandler)
        
        // Simulate pipeline cleanup by exiting autoreleasepool
        // Handler should be deallocated
        XCTAssertNil(weakHandler, "Handler should be deallocated when pipeline is released")
    }
    
    // MARK: - Middleware Failures
    
    func testMiddlewareException() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let faultyMiddleware = FaultyMiddleware()
        
        try await pipeline.addMiddleware(faultyMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        let context = CommandContext.test()
        
        do {
            _ = try await pipeline.execute(command, context: context)
            XCTFail("Middleware exception should propagate")
        } catch MiddlewareError.executionFailed {
            // Expected error
        }
    }
    
    func testMiddlewareChainFailure() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        
        // Add multiple middleware, with one that fails
        // Add a simple no-op middleware instead of LoggingMiddleware
        try await pipeline.addMiddleware(NoOpMiddleware(id: 1))
        try await pipeline.addMiddleware(FaultyMiddleware()) // This will fail
        try await pipeline.addMiddleware(ValidationMiddleware())
        
        let command = PipelineTestCommand(value: "test")
        let context = CommandContext.test()
        
        do {
            _ = try await pipeline.execute(command, context: context)
            XCTFail("Middleware chain failure should propagate")
        } catch MiddlewareError.executionFailed {
            // Expected - middleware chain should stop at first failure
        }
    }
    
    func testMiddlewareNextNotCalled() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let shortCircuitMiddleware = ShortCircuitMiddleware()
        
        try await pipeline.addMiddleware(shortCircuitMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        let context = CommandContext.test()
        
        // This should work but return short-circuited result
        let result = try await pipeline.execute(command, context: context)
        XCTAssertEqual(result, "short_circuit")
    }
    
    func testMiddlewareInfiniteLoop() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler(), maxConcurrency: 5)
        
        // Add more middleware than max depth allows
        for i in 0..<10 {
            do {
                try await pipeline.addMiddleware(NoOpMiddleware(id: i))
            } catch PipelineError.maxDepthExceeded(_, _) {
                // Expected after hitting max depth
                break
            }
        }
        
        // Pipeline should enforce depth limit
        // Pipeline should enforce depth limit (check is performed during add)
    }
    
    // MARK: - Context Corruption
    
    func testContextCorruption() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let corruptingMiddleware = ContextCorruptingMiddleware()
        
        try await pipeline.addMiddleware(corruptingMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        let context = CommandContext.test()
        
        do {
            _ = try await pipeline.execute(command, context: context)
            XCTFail("Context corruption should be detected")
        } catch {
            // Expected error - middleware throws a custom error
            XCTAssertTrue(error is TestError)
        }
    }
    
    func testContextMemoryLeak() async throws {
        /// Thread Safety: Uses NSLock to protect weak reference access
        /// Invariant: All weak reference operations are synchronized through NSLock
        final class WeakContextHolder: @unchecked Sendable {
            private let lock = NSLock()
            weak var context: CommandContext?
            
            func setContext(_ ctx: CommandContext) {
                lock.lock()
                defer { lock.unlock() }
                self.context = ctx
            }
            
            func getContext() -> CommandContext? {
                lock.lock()
                defer { lock.unlock() }
                return context
            }
        }
        
        let contextHolder = WeakContextHolder()
        
        do {
            let pipeline = StandardPipeline(handler: PipelineTestHandler())
            let contextCapturingMiddleware = ContextCapturingMiddleware { context in
                contextHolder.setContext(context)
            }
            
            try await pipeline.addMiddleware(contextCapturingMiddleware)
            
            let command = PipelineTestCommand(value: "test")
            let context = CommandContext.test()
            
            _ = try await pipeline.execute(command, context: context)
        }
        
        // Context should be deallocated after execution
        XCTAssertNil(contextHolder.getContext(), "Context should not leak after execution")
    }
    
    func testContextRaceCondition() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let racingMiddleware = ContextRacingMiddleware()
        
        try await pipeline.addMiddleware(racingMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        
        // Execute multiple commands concurrently to trigger race condition
        let tasks = (0..<10).map { _ in
            Task {
                let context = CommandContext.test()
                return try await pipeline.execute(command, context: context)
            }
        }
        
        // All tasks should complete successfully without data races
        for task in tasks {
            let result = try await task.value
            XCTAssertEqual(result, "Handled: test")
        }
    }
    
    // MARK: - Resource Exhaustion
    
    func testMemoryExhaustion() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let memoryHogMiddleware = MemoryHogMiddleware()
        
        try await pipeline.addMiddleware(memoryHogMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        let context = CommandContext.test()
        
        // This test verifies graceful handling under memory pressure
        do {
            _ = try await pipeline.execute(command, context: context)
            // If it completes, memory management is working
        } catch {
            // If it fails due to memory pressure, that's also valid
            XCTAssertTrue(error.localizedDescription.contains("memory") ||
                         error.localizedDescription.contains("resource"))
        }
    }
    
    func testMaxConcurrencyExceeded() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let concurrencyLimitMiddleware = ConcurrencyLimitMiddleware(maxConcurrent: 2)
        
        try await pipeline.addMiddleware(concurrencyLimitMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        
        // Execute more tasks than the concurrency limit
        let tasks = (0..<5).map { _ in
            Task {
                let context = CommandContext.test()
                return try await pipeline.execute(command, context: context)
            }
        }
        
        // All should eventually complete
        for task in tasks {
            _ = try await task.value
        }
    }
    
    // MARK: - Error Recovery
    
    func testErrorRecoveryMiddleware() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let errorRecoveryMiddleware = ErrorRecoveryMiddleware()
        let faultyMiddleware = FaultyMiddleware()
        
        try await pipeline.addMiddleware(errorRecoveryMiddleware)
        try await pipeline.addMiddleware(faultyMiddleware)
        
        let command = PipelineTestCommand(value: "test")
        let context = CommandContext.test()
        
        // Error recovery should handle the fault
        let result = try await pipeline.execute(command, context: context)
        XCTAssertEqual(result, "recovered")
    }
    
    func testPartialFailureHandling() async throws {
        let pipeline = StandardPipeline(handler: PipelineTestHandler())
        let partialFailureMiddleware = PartialFailureMiddleware()
        
        try await pipeline.addMiddleware(partialFailureMiddleware)
        
        let command = PipelineTestCommand(value: "partial_fail")
        let context = CommandContext.test()
        
        do {
            _ = try await pipeline.execute(command, context: context)
            XCTFail("Partial failure should be handled")
        } catch PartialFailureError.someOperationsFailed {
            // Expected
        }
    }
}

// MARK: - Test Middleware Implementations

struct NoOpMiddleware: Middleware {
    let id: Int
    
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        return try await next(command, context)
    }
}

struct FaultyMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        throw MiddlewareError.executionFailed
    }
}

struct ShortCircuitMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        if let result = "short_circuit" as? T.Result {
            return result
        }
        throw PipelineError.executionFailed(message: "Cannot convert short_circuit result", context: nil)
    }
}

struct PipelineValidationMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        // Validate command
        return try await next(command, context)
    }
}

struct ContextCorruptingMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        // Simulate context corruption by setting an unexpected value
        context.metadata["test_custom_value"] = "corrupted"
        throw TestError.middlewareFailed
    }
}

struct ContextCapturingMiddleware: Middleware {
    let onCapture: @Sendable (CommandContext) async -> Void
    
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        await onCapture(context)
        return try await next(command, context)
    }
}

// Context keys for racing test
private enum RacingKeys {
    static let key1 = "racing_key_1"
    static let key2 = "racing_key_2"
}

struct ContextRacingMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        // Simulate concurrent context access
        async let set1: Void = context.metadata[RacingKeys.key1] = "value1"
        async let set2: Void = context.metadata[RacingKeys.key2] = "value2"
        async let get1: String? = (context.metadata[RacingKeys.key1] as? String)
        async let get2: String? = (context.metadata[RacingKeys.key2] as? String)
        
        await set1
        await set2
        _ = await get1
        _ = await get2
        
        return try await next(command, context)
    }
}

private enum LargeDataKeys {
    static let largeData = "large_data_key"
}

struct MemoryHogMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        // Allocate large amount of memory
        let largeData = Array(repeating: "memory", count: 1_000_000)
        context.metadata[LargeDataKeys.largeData] = largeData
        return try await next(command, context)
    }
}

struct ConcurrencyLimitMiddleware: Middleware {
    let maxConcurrent: Int
    private let semaphore: AsyncSemaphore
    
    init(maxConcurrent: Int) {
        self.maxConcurrent = maxConcurrent
        self.semaphore = AsyncSemaphore(value: maxConcurrent)
    }
    
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        await semaphore.wait()
        do {
            let result = try await next(command, context)
            await semaphore.signal()
            return result
        } catch {
            await semaphore.signal()
            throw error
        }
    }
}

struct ErrorRecoveryMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        do {
            return try await next(command, context)
        } catch {
            // Recover from error
            if let recoveredResult = "recovered" as? T.Result {
                return recoveredResult
            }
            throw PipelineError.executionFailed(message: "Recovery failed - cannot convert result", context: nil)
        }
    }
}

struct PartialFailureMiddleware: Middleware {
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        if let cmd = command as? PipelineTestCommand,
           cmd.value == "partial_fail" {
            throw PartialFailureError.someOperationsFailed
        }
        return try await next(command, context)
    }
}

// MARK: - Test Handler Implementations

struct PipelineFaultyHandler: CommandHandler {
    typealias CommandType = PipelineTestCommand
    
    func handle(_ command: PipelineTestCommand) async throws -> String {
        if command.value == "trigger_error" {
            throw HandlerError.processingFailed
        }
        return "Handled: \(command.value)"
    }
}

struct PipelineSlowHandler: CommandHandler {
    typealias CommandType = PipelineTestCommand
    
    func handle(_ command: PipelineTestCommand) async throws -> String {
        if command.value == "slow_operation" {
            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second (still much longer than 0.1s timeout)
        }
        return "Handled: \(command.value)"
    }
}

/// Thread Safety: Test handler with intentionally unsafe array for leak testing
/// Invariant: Array is intentionally not synchronized to simulate memory leaks
final class PipelineLeakyHandler: CommandHandler, @unchecked Sendable {
    typealias CommandType = PipelineTestCommand
    
    private var retainedData: [String] = []
    
    func handle(_ command: PipelineTestCommand) async throws -> String {
        retainedData.append(command.value)
        return "Handled: \(command.value)"
    }
}

// MARK: - Error Types

enum HandlerError: Error {
    case processingFailed
}

enum MiddlewareError: Error {
    case executionFailed
}

enum ContextError: Error {
    case corruptedState
}

enum PartialFailureError: Error {
    case someOperationsFailed
}

// PipelineTimeoutError removed - using PipelineError.cancelled instead

// MARK: - Helper Functions

func withPipelineTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
    try await withThrowingTaskGroup(of: T.self) { group in
        group.addTask {
            try await operation()
        }
        
        group.addTask {
            try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
            throw PipelineError.cancelled(context: "Pipeline timeout after \(seconds) seconds")
        }
        
        let result = try await group.next()!
        group.cancelAll()
        return result
    }
}

// MARK: - Async Semaphore Helper

actor AsyncSemaphore {
    private var value: Int
    private var waiters: [CheckedContinuation<Void, Never>] = []
    
    init(value: Int) {
        self.value = value
    }
    
    func wait() async {
        if value > 0 {
            value -= 1
        } else {
            await withCheckedContinuation { continuation in
                waiters.append(continuation)
            }
        }
    }
    
    func signal() {
        if let waiter = waiters.first {
            waiters.removeFirst()
            waiter.resume()
        } else {
            value += 1
        }
    }
}
