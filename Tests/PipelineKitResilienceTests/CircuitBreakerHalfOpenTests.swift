import XCTest
@testable import PipelineKit
import PipelineKitTestSupport

final class CircuitBreakerHalfOpenTests: XCTestCase {
    private let synchronizer = TestSynchronizer()
    
    // MARK: - Half-Open Success Count Tests
    
    func testHalfOpenSuccessCountTracking() async throws {
        // Given
        let breaker = CircuitBreaker(
            failureThreshold: 1,
            successThreshold: 3,
            timeout: 0.1
        )
        
        // Open the breaker
        await breaker.recordFailure()
        
        // Wait for timeout to transition to half-open
        await synchronizer.longDelay()
        
        // First probe should be allowed
        let probe1 = await breaker.allowRequest()
        XCTAssertTrue(probe1, "First probe should be allowed")
        
        // Record success
        await breaker.recordSuccess()
        
        // Verify still in half-open state (need 3 successes to close)
        let state1 = await breaker.getState()
        if case .halfOpen = state1 {
            // Expected
        } else {
            XCTFail("Should still be half-open after 1 success")
        }
        
        // Second probe should be allowed
        let probe2 = await breaker.allowRequest()
        XCTAssertTrue(probe2, "Second probe should be allowed")
        await breaker.recordSuccess()
        
        // Still half-open
        let state2 = await breaker.getState()
        if case .halfOpen = state2 {
            // Expected
        } else {
            XCTFail("Should still be half-open after 2 successes")
        }
        
        // Third probe and success should close the circuit
        let probe3 = await breaker.allowRequest()
        XCTAssertTrue(probe3, "Third probe should be allowed")
        await breaker.recordSuccess()
        
        // Should now be closed
        let finalState = await breaker.getState()
        if case .closed = finalState {
            // Expected
        } else {
            XCTFail("Should be closed after reaching success threshold")
        }
    }
    
    func testHalfOpenSuccessCountResetsOnFailure() async throws {
        // Given
        let breaker = CircuitBreaker(
            failureThreshold: 1,
            successThreshold: 3,
            timeout: 0.1
        )
        
        // Open the breaker
        await breaker.recordFailure()
        await synchronizer.longDelay()
        
        // Record two successes
        let probe1 = await breaker.allowRequest()
        XCTAssertTrue(probe1)
        await breaker.recordSuccess()
        
        let probe2 = await breaker.allowRequest()
        XCTAssertTrue(probe2)
        await breaker.recordSuccess()
        
        // Now a failure should reset the count and re-open
        let probe3 = await breaker.allowRequest()
        XCTAssertTrue(probe3)
        await breaker.recordFailure()
        
        // Should be open again
        let state = await breaker.getState()
        if case .open = state {
            // Expected
        } else {
            XCTFail("Should be open after failure in half-open state")
        }
        
        // Wait for another timeout
        await synchronizer.longDelay()
        
        // Should need 3 successes again (count was reset)
        for i in 0..<3 {
            let probe = await breaker.allowRequest()
            XCTAssertTrue(probe, "Probe \(i+1) should be allowed")
            await breaker.recordSuccess()
            
            if i < 2 {
                let intermediateState = await breaker.getState()
                if case .halfOpen = intermediateState {
                    // Expected
                } else {
                    XCTFail("Should still be half-open after \(i+1) successes")
                }
            }
        }
        
        // Should be closed after 3 successes
        let finalState = await breaker.getState()
        if case .closed = finalState {
            // Expected
        } else {
            XCTFail("Should be closed after reaching success threshold again")
        }
    }
    
    func testHalfOpenWithSuccessThresholdOfOne() async throws {
        // Given
        let breaker = CircuitBreaker(
            failureThreshold: 1,
            successThreshold: 1,
            timeout: 0.1
        )
        
        // Open the breaker
        await breaker.recordFailure()
        await synchronizer.longDelay()
        
        // Single success should close immediately
        let probe = await breaker.allowRequest()
        XCTAssertTrue(probe)
        await breaker.recordSuccess()
        
        // Should be closed
        let state = await breaker.getState()
        if case .closed = state {
            // Expected
        } else {
            XCTFail("Should be closed after single success with threshold of 1")
        }
    }
    
    func testHalfOpenSuccessCountDoesNotAffectClosedState() async throws {
        // Given
        let breaker = CircuitBreaker(
            failureThreshold: 3,
            successThreshold: 2,
            timeout: 0.1
        )
        
        // Record successes in closed state
        for _ in 0..<5 {
            await breaker.recordSuccess()
        }
        
        // Should still be closed
        let state1 = await breaker.getState()
        if case .closed = state1 {
            // Expected
        } else {
            XCTFail("Should remain closed")
        }
        
        // Record some failures (but not enough to open)
        await breaker.recordFailure()
        await breaker.recordFailure()
        
        // Still closed
        let state2 = await breaker.getState()
        if case .closed = state2 {
            // Expected
        } else {
            XCTFail("Should still be closed")
        }
        
        // One more failure opens it
        await breaker.recordFailure()
        
        // Should be open
        let state3 = await breaker.getState()
        if case .open = state3 {
            // Expected
        } else {
            XCTFail("Should be open after failure threshold")
        }
        
        // Wait for half-open
        await synchronizer.longDelay()
        
        // Should still need 2 successes (not affected by previous successes in closed state)
        let probe1 = await breaker.allowRequest()
        XCTAssertTrue(probe1)
        await breaker.recordSuccess()
        
        // Still half-open
        let state4 = await breaker.getState()
        if case .halfOpen = state4 {
            // Expected
        } else {
            XCTFail("Should still be half-open after 1 success")
        }
        
        let probe2 = await breaker.allowRequest()
        XCTAssertTrue(probe2)
        await breaker.recordSuccess()
        
        // Now closed
        let finalState = await breaker.getState()
        if case .closed = finalState {
            // Expected
        } else {
            XCTFail("Should be closed after success threshold")
        }
    }
    
    func testRapidHalfOpenTransitions() async throws {
        // Given
        let breaker = CircuitBreaker(
            failureThreshold: 1,
            successThreshold: 2,
            timeout: 0.05
        )
        
        // Rapid transitions through states
        for cycle in 0..<3 {
            // Open
            await breaker.recordFailure()
            
            // Wait for half-open
            await synchronizer.mediumDelay()
            
            // Success in half-open
            let probe1 = await breaker.allowRequest()
            XCTAssertTrue(probe1, "Cycle \(cycle): First probe should be allowed")
            await breaker.recordSuccess()
            
            // Another success to close
            let probe2 = await breaker.allowRequest()
            XCTAssertTrue(probe2, "Cycle \(cycle): Second probe should be allowed")
            await breaker.recordSuccess()
            
            // Verify closed
            let state = await breaker.getState()
            if case .closed = state {
                // Expected
            } else {
                XCTFail("Cycle \(cycle): Should be closed after success threshold")
            }
        }
    }
    
    // MARK: - Concurrent Half-Open Tests
    
    func testConcurrentHalfOpenSuccesses() async throws {
        // Given
        let breaker = CircuitBreaker(
            failureThreshold: 1,
            successThreshold: 5,
            timeout: 0.1
        )
        
        // Open the breaker
        await breaker.recordFailure()
        await synchronizer.longDelay()
        
        // Test that probe window limiting prevents concurrent probes
        var probeResults: [Bool] = []
        
        // Try multiple concurrent probe requests
        await withTaskGroup(of: Bool.self) { group in
            for _ in 0..<10 {
                group.addTask {
                    await breaker.allowRequest()
                }
            }
            
            for await result in group {
                probeResults.append(result)
            }
        }
        
        // Only one probe should be allowed due to probe window limiting
        let allowedCount = probeResults.filter { $0 }.count
        XCTAssertEqual(allowedCount, 1, "Only one probe should be allowed concurrently")
        
        // Record success for the allowed probe
        await breaker.recordSuccess()
        
        // Now test sequential probes to reach success threshold
        for i in 1..<5 {
            let allowed = await breaker.allowRequest()
            XCTAssertTrue(allowed, "Sequential probe \(i+1) should be allowed")
            await breaker.recordSuccess()
            
            if i < 4 {
                let state = await breaker.getState()
                if case .halfOpen = state {
                    // Expected
                } else {
                    XCTFail("Should still be half-open after \(i+1) successes")
                }
            }
        }
        
        // Should be closed after 5 successes
        let finalState = await breaker.getState()
        if case .closed = finalState {
            // Expected
        } else {
            XCTFail("Should be closed after reaching success threshold")
        }
    }
}