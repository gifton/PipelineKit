import XCTest
@testable import PipelineKitMetrics
import PipelineKitCore

final class OTLPExporterTests: XCTestCase {

    func testDefaultConfiguration() {
        let config = OTLPExporter.Configuration.default

        XCTAssertEqual(config.endpoint.absoluteString, "http://localhost:4318/v1/metrics")
        XCTAssertEqual(config.timeout, 10.0)
        XCTAssertEqual(config.serviceName, "PipelineKit")
        XCTAssertTrue(config.compression)
        XCTAssertEqual(config.maxRetries, 3)
        XCTAssertEqual(config.retryDelay, 1.0)
    }

    func testCustomConfiguration() {
        let config = OTLPExporter.Configuration(
            endpoint: URL(string: "https://collector.example.com/v1/metrics")!,
            headers: ["Authorization": "Bearer token123"],
            timeout: 30.0,
            resourceAttributes: ["environment": "production", "region": "us-west-2"],
            serviceName: "MyService",
            compression: false,
            maxRetries: 5,
            retryDelay: 2.0
        )

        XCTAssertEqual(config.endpoint.absoluteString, "https://collector.example.com/v1/metrics")
        XCTAssertEqual(config.headers["Authorization"], "Bearer token123")
        XCTAssertEqual(config.timeout, 30.0)
        XCTAssertEqual(config.resourceAttributes["environment"], "production")
        XCTAssertEqual(config.resourceAttributes["region"], "us-west-2")
        XCTAssertEqual(config.serviceName, "MyService")
        XCTAssertFalse(config.compression)
        XCTAssertEqual(config.maxRetries, 5)
        XCTAssertEqual(config.retryDelay, 2.0)
    }

    func testExporterInitialization() async {
        let exporter = OTLPExporter()

        // Should not crash on empty export
        do {
            try await exporter.export([])
        } catch {
            XCTFail("Empty export should not throw: \(error)")
        }
    }

    func testMetricConversion() async throws {
        // This test would need a mock server or test double for the URLSession
        // For now, we test that the exporter accepts various metric types

        let exporter = OTLPExporter(
            configuration: OTLPExporter.Configuration(
                endpoint: URL(string: "http://localhost:9999/v1/metrics")!, // Non-existent endpoint
                maxRetries: 1,
                retryDelay: 0.1
            )
        )

        let metrics = [
            // Counter metric
            MetricSnapshot(
                name: "requests.total",
                type: "counter",
                value: 100,
                timestamp: Date(),
                tags: ["method": "GET", "status": "200"],
                unit: "count"
            ),

            // Gauge metric
            MetricSnapshot(
                name: "memory.usage",
                type: "gauge",
                value: 75.5,
                timestamp: Date(),
                tags: ["process": "api-server"],
                unit: "percent"
            ),

            // Histogram metric (simplified as gauge in our implementation)
            MetricSnapshot(
                name: "request.duration",
                type: "histogram",
                value: 125.5,
                timestamp: Date(),
                tags: ["endpoint": "/api/users"],
                unit: "milliseconds"
            )
        ]

        // This will fail due to connection error, but we're testing it doesn't crash
        do {
            try await exporter.export(metrics)
            XCTFail("Should have thrown an error for unreachable endpoint")
        } catch {
            // Expected to fail with network error
            // This validates that the exporter properly handles errors
        }
    }

    func testExporterLifecycle() async throws {
        let exporter = OTLPExporter()

        // Test flush (should be no-op)
        try await exporter.flush()

        // Test shutdown
        await exporter.shutdown()
    }

    func testBatchingWithOTLP() async throws {
        // Test that OTLP exporter works with BatchingExporter
        let otlpExporter = OTLPExporter(
            configuration: OTLPExporter.Configuration(
                endpoint: URL(string: "http://localhost:9999/v1/metrics")!,
                maxRetries: 1,
                retryDelay: 0.1
            )
        )

        let batchingExporter = await BatchingExporter(
            underlying: otlpExporter,
            maxBatchSize: 10,
            autostart: false // Don't start timer for test
        )

        // Add metrics that won't trigger auto-flush
        let metric = MetricSnapshot(
            name: "test.metric",
            type: "counter",
            value: 1,
            timestamp: Date(),
            tags: [:],
            unit: "count"
        )

        for _ in 0..<5 {
            try? await batchingExporter.export([metric])
        }

        // Metrics should be buffered
        let stats = await batchingExporter.getStats()
        XCTAssertEqual(stats.currentBufferSize, 5)

        // Flush should attempt to send (and fail due to unreachable endpoint)
        do {
            try await batchingExporter.flush()
            XCTFail("Should have thrown an error for unreachable endpoint")
        } catch {
            // Expected - validates batching works with OTLP
        }
    }

    func testMultiExporterWithOTLP() async throws {
        // Test that OTLP works in a multi-exporter setup
        let otlpExporter = OTLPExporter()
        let consoleExporter = ConsoleExporter(format: .compact)
        let nullExporter = NullExporter()

        let multiExporter = MultiExporter(exporters: [
            consoleExporter,
            otlpExporter,
            nullExporter
        ])

        let metrics = [
            MetricSnapshot(
                name: "multi.test",
                type: "gauge",
                value: 42.0,
                timestamp: Date(),
                tags: ["exporter": "multi"],
                unit: nil
            )
        ]

        // This will fail for OTLP but succeed for console and null
        // Due to fail-fast, the first error will propagate
        do {
            try await multiExporter.export(metrics)
            // If this succeeds, OTLP endpoint is actually running (unlikely in test)
        } catch {
            // Expected in test environment without OTLP collector
        }
    }

    func testResourceAttributes() async {
        let config = OTLPExporter.Configuration(
            endpoint: URL(string: "http://localhost:4318")!,
            resourceAttributes: [
                "deployment.environment": "staging",
                "service.version": "1.2.3",
                "host.name": "api-server-01"
            ],
            serviceName: "TestService"
        )

        let exporter = OTLPExporter(configuration: config)

        // Verify configuration is stored correctly
        // In a real test, we'd intercept the HTTP request to verify the payload
        XCTAssertNotNil(exporter)
    }
}

