import XCTest
@testable import PipelineKitCore
import PipelineKitTestSupport

/// Tests for pool shrink throttling mechanism
final class PoolThrottlingTests: XCTestCase {
    
    // MARK: - Test Helpers
    
    final class TestObject: Sendable {
        let id = UUID()
    }
    
    override func setUp() async throws {
        // Reset throttling configuration for tests
        PoolRegistry.minimumShrinkInterval = 10.0
    }
    
    // MARK: - Throttling Tests
    
    func testThrottlingPreventsRapidShrinks() async {
        // Given
        let pool = ObjectPool<TestObject>(
            name: "throttle-test",
            configuration: ObjectPoolConfiguration(maxSize: 100, trackStatistics: true),
            factory: { TestObject() },
            registerMetrics: true
        )
        
        await pool.preallocate(count: 100)
        
        // Wait for registration
        try? await Task.sleep(nanoseconds: 100_000_000)
        
        // Set a shorter interval for testing
        PoolRegistry.minimumShrinkInterval = 1.0
        
        // When - First shrink should succeed
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.8)
        
        let firstStats = await pool.statistics
        XCTAssertLessThanOrEqual(firstStats.currentlyAvailable, 80)
        
        // Immediately try another shrink - should be throttled
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.5)
        
        let throttledStats = await pool.statistics
        XCTAssertEqual(throttledStats.currentlyAvailable, firstStats.currentlyAvailable, 
                      "Second shrink should be throttled")
        
        // Check throttled count increased
        let throttledCount = await PoolRegistry.shared.throttledRequests
        XCTAssertGreaterThan(throttledCount, 0, "Should track throttled requests")
        
        // Wait for throttle period
        try? await Task.sleep(nanoseconds: 1_100_000_000) // 1.1 seconds
        
        // Now shrink should work
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.5)
        
        let finalStats = await pool.statistics
        XCTAssertLessThanOrEqual(finalStats.currentlyAvailable, 50, 
                                 "Shrink should work after throttle period")
    }
    
    func testForceParameterBypassesThrottling() async {
        // Given
        let pool = ObjectPool<TestObject>(
            name: "force-test",
            configuration: ObjectPoolConfiguration(maxSize: 100, trackStatistics: true),
            factory: { TestObject() },
            registerMetrics: true
        )
        
        await pool.preallocate(count: 100)
        
        // Wait for registration
        try? await Task.sleep(nanoseconds: 100_000_000)
        
        // When - Multiple rapid shrinks with force=true
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.8, force: true)
        let stats1 = await pool.statistics
        
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.6, force: true)
        let stats2 = await pool.statistics
        
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.4, force: true)
        let stats3 = await pool.statistics
        
        // Then - All shrinks should succeed
        XCTAssertLessThanOrEqual(stats1.currentlyAvailable, 80)
        XCTAssertLessThanOrEqual(stats2.currentlyAvailable, 60)
        XCTAssertLessThanOrEqual(stats3.currentlyAvailable, 40)
    }
    
    func testStartupBurstExemption() async {
        // This test would need to run at process startup to be effective
        // Just verify the logic exists
        
        let uptime = ProcessInfo.processInfo.systemUptime
        print("Process uptime: \(uptime) seconds")
        
        // If running within 30 seconds of startup, throttling should be skipped
        if uptime < 30.0 {
            // Create pool and test rapid shrinking
            let pool = ObjectPool<TestObject>(
                name: "startup-test",
                configuration: ObjectPoolConfiguration(maxSize: 100),
                factory: { TestObject() },
                registerMetrics: true
            )
            
            await pool.preallocate(count: 100)
            
            // Rapid shrinks should all work during startup period
            for percentage in stride(from: 0.9, through: 0.1, by: -0.1) {
                await PoolRegistry.shared.shrinkAllPools(toPercentage: percentage)
            }
            
            let finalStats = await pool.statistics
            XCTAssertLessThanOrEqual(finalStats.currentlyAvailable, 10)
        }
    }
    
    func testPerPoolThrottling() async {
        // Given - Multiple pools
        let pool1 = ObjectPool<TestObject>(
            name: "pool-1",
            configuration: ObjectPoolConfiguration(maxSize: 100, trackStatistics: true),
            factory: { TestObject() },
            registerMetrics: true
        )
        
        let pool2 = ObjectPool<TestObject>(
            name: "pool-2",
            configuration: ObjectPoolConfiguration(maxSize: 100, trackStatistics: true),
            factory: { TestObject() },
            registerMetrics: true
        )
        
        await pool1.preallocate(count: 100)
        await pool2.preallocate(count: 100)
        
        // Wait for registration
        try? await Task.sleep(nanoseconds: 100_000_000)
        
        // Set short interval for testing
        PoolRegistry.minimumShrinkInterval = 0.5
        
        // When - Shrink pool1
        await PoolRegistry.shared.shrinkPool(name: "pool-1", to: 50)
        
        // Immediately shrink pool2 - should work (different pool)
        await PoolRegistry.shared.shrinkPool(name: "pool-2", to: 50)
        
        let stats1 = await pool1.statistics
        let stats2 = await pool2.statistics
        
        // Then - Both should be shrunk (per-pool throttling)
        XCTAssertEqual(stats1.currentlyAvailable, 50)
        XCTAssertEqual(stats2.currentlyAvailable, 50)
        
        // But rapid shrink of same pool should be throttled
        await PoolRegistry.shared.shrinkPool(name: "pool-1", to: 25)
        
        let throttledStats = await pool1.statistics
        XCTAssertEqual(throttledStats.currentlyAvailable, 50, 
                      "Second shrink of same pool should be throttled")
    }
    
    func testThrottlingWithCriticalPressure() async {
        // Given
        let collector = PoolMetricsCollector()
        let pool = ObjectPool<TestObject>(
            name: "critical-test",
            configuration: ObjectPoolConfiguration(maxSize: 100, trackStatistics: true),
            factory: { TestObject() },
            registerMetrics: true
        )
        
        await pool.preallocate(count: 100)
        await collector.startCollecting()
        
        // Wait for setup
        try? await Task.sleep(nanoseconds: 100_000_000)
        
        // When - First shrink
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.8)
        
        // Critical pressure should force shrink even within throttle period
        // This simulates what PoolMetricsCollector does
        await PoolRegistry.shared.shrinkAllPools(toPercentage: 0.0, force: true)
        
        // Then
        let stats = await pool.statistics
        XCTAssertEqual(stats.currentlyAvailable, 0, 
                      "Critical pressure with force=true should bypass throttling")
        
        // Cleanup
        await collector.stopCollecting()
    }
    
    func testSyncUnregisterDoesntHang() async {
        // Given - Pool that will be deallocated
        class PoolWrapper {
            let pool: ObjectPool<TestObject>
            
            init() {
                pool = ObjectPool<TestObject>(
                    name: "sync-test",
                    configuration: ObjectPoolConfiguration(maxSize: 10),
                    factory: { TestObject() },
                    registerMetrics: true
                )
            }
        }
        
        // When - Create and destroy many pools rapidly
        for _ in 0..<100 {
            let wrapper = PoolWrapper()
            await wrapper.pool.preallocate(count: 5)
            // Pool deallocates here, triggering sync unregister
        }
        
        // Then - Should not hang or timeout
        let stats = await PoolRegistry.shared.getAggregatedStatistics()
        XCTAssertNotNil(stats)
        
        // Most pools should be cleaned up
        XCTAssertLessThan(stats.activePoolCount, 10)
    }
    
    func testThrottleIntervalConfiguration() async {
        // Given - Custom throttle interval
        let originalInterval = PoolRegistry.minimumShrinkInterval
        PoolRegistry.minimumShrinkInterval = 0.1 // Very short for testing
        
        defer {
            PoolRegistry.minimumShrinkInterval = originalInterval
        }
        
        let pool = ObjectPool<TestObject>(
            name: "interval-test",
            configuration: ObjectPoolConfiguration(maxSize: 100),
            factory: { TestObject() },
            registerMetrics: true
        )
        
        await pool.preallocate(count: 100)
        
        // When - Rapid shrinks with short interval
        await pool.shrink(to: 80)
        
        // Should be throttled immediately
        await pool.shrink(to: 60)
        var stats = await pool.statistics
        XCTAssertEqual(stats.currentlyAvailable, 80, "Should be throttled")
        
        // Wait for short interval
        try? await Task.sleep(nanoseconds: 150_000_000) // 150ms
        
        // Should work now
        await pool.shrink(to: 60)
        stats = await pool.statistics
        XCTAssertEqual(stats.currentlyAvailable, 60, "Should work after interval")
    }
}