import XCTest
@testable import PipelineKitCore
import PipelineKitTestSupport

final class CommandContextForkTests: XCTestCase {
    // MARK: - Test Keys
    
    private enum TestKeys {
        static let testKey = "test_key"
        static let counterKey = "counter_key"
        static let dataKey = "data_key"
    }
    
    // MARK: - Fork Tests
    
    func testContextForkCreatesIndependentCopy() async {
        // Given
        let original = CommandContext()
        await original.set("original", for: TestKeys.testKey)
        await original.set(42, for: TestKeys.counterKey)
        
        // When
        let forked = await original.fork()
        
        // Then - Forked has same values
        let forkedTest: String? = await forked.get(String.self, for: TestKeys.testKey)
        let forkedCounter: Int? = await forked.get(Int.self, for: TestKeys.counterKey)
        XCTAssertEqual(forkedTest, "original")
        XCTAssertEqual(forkedCounter, 42)
        
        // When - Modify forked
        await forked.set("forked", for: TestKeys.testKey)
        await forked.set(99, for: TestKeys.counterKey)
        
        // Then - Original unchanged
        let originalTest: String? = await original.get(String.self, for: TestKeys.testKey)
        let originalCounter: Int? = await original.get(Int.self, for: TestKeys.counterKey)
        XCTAssertEqual(originalTest, "original")
        XCTAssertEqual(originalCounter, 42)
        
        // And - Forked has new values
        let forkedTestNew: String? = await forked.get(String.self, for: TestKeys.testKey)
        let forkedCounterNew: Int? = await forked.get(Int.self, for: TestKeys.counterKey)
        XCTAssertEqual(forkedTestNew, "forked")
        XCTAssertEqual(forkedCounterNew, 99)
    }
    
    func testContextForkSharesMetadata() async {
        // Given
        let metadata = TestCommandMetadata(userId: "test-user")
        let original = CommandContext(metadata: metadata)
        
        // When
        let forked = await original.fork()
        
        // Then - Both have same metadata
        XCTAssertEqual(original.commandMetadata.userId, "test-user")
        XCTAssertEqual(forked.commandMetadata.userId, "test-user")
        // Note: CommandMetadata is a protocol, not necessarily a class, so we can't use ===
    }
    
    // MARK: - Merge Tests
    
    func testContextMergeUpdatesValues() async {
        // Given
        let context1 = CommandContext()
        await context1.set("value1", for: TestKeys.testKey)
        await context1.set(10, for: TestKeys.counterKey)
        
        let context2 = CommandContext()
        await context2.set("value2", for: TestKeys.testKey)
        // Store a Sendable dictionary instead of [String: Any]
        struct SendableData: Sendable {
            let data: [String: String]
        }
        await context2.set(SendableData(data: ["key": "value"]), for: TestKeys.dataKey)
        
        // When
        await context1.merge(from: context2)
        
        // Then
        let testValue: String? = await context1.get(String.self, for: TestKeys.testKey)
        let counterValue: Int? = await context1.get(Int.self, for: TestKeys.counterKey)
        let dataValue: SendableData? = await context1.get(SendableData.self, for: TestKeys.dataKey)
        
        XCTAssertEqual(testValue, "value2") // Overwritten
        XCTAssertEqual(counterValue, 10) // Unchanged
        XCTAssertEqual(dataValue?.data["key"], "value") // Added
    }
    
    func testContextMergeDoesNotAffectSource() async {
        // Given
        let source = CommandContext()
        await source.set("source", for: TestKeys.testKey)
        
        let target = CommandContext()
        await target.set("target", for: TestKeys.testKey)
        
        // When
        await target.merge(from: source)
        
        // Then
        let sourceValue: String? = await source.get(String.self, for: TestKeys.testKey)
        let targetValue: String? = await target.get(String.self, for: TestKeys.testKey)
        
        XCTAssertEqual(sourceValue, "source") // Source unchanged
        XCTAssertEqual(targetValue, "source") // Target updated
    }
    
    // MARK: - Parallel Execution Tests
    
    func testParallelContextModificationWithForking() async {
        // Given
        let original = CommandContext()
        await original.set(0, for: TestKeys.counterKey)
        
        // When - Parallel modifications on forked contexts
        await withTaskGroup(of: Void.self) { group in
            for i in 1...100 {
                group.addTask {
                    Task {
                        let forked = await original.fork()
                        let current: Int = await forked.get(Int.self, for: TestKeys.counterKey) ?? 0
                        await forked.set(current + i, for: TestKeys.counterKey)
                        // Forked context is discarded - no race condition
                    }
                }
            }
        }
        
        // Then - Original unchanged
        let originalValue: Int? = await original.get(Int.self, for: TestKeys.counterKey)
        XCTAssertEqual(originalValue, 0)
    }
    
    func testParallelMiddlewareWithContextForking() async throws {
        // Given
        let handler = MockCommandHandler()
        
        // Create middleware that modifies context
        let middleware1 = ContextModifyingMiddleware(key: "MW1", value: "value1")
        let middleware2 = ContextModifyingMiddleware(key: "MW2", value: "value2")
        let middleware3 = ContextModifyingMiddleware(key: "MW3", value: "value3")
        
        // Create parallel wrapper
        let parallelWrapper = ParallelMiddlewareWrapper(
            middlewares: [middleware1, middleware2, middleware3],
            strategy: .sideEffectsWithMerge
        )
        
        let pipeline = try await PipelineBuilder(handler: handler)
            .with(parallelWrapper)
            .build()
        
        let command = MockCommand(value: 42)
        let context = CommandContext()
        
        // When
        _ = try await pipeline.execute(command, context: context)
        
        // Then - All middleware changes are merged
        let mw1Value: String? = (context.metadata["MW1"] as? String)
        let mw2Value: String? = (context.metadata["MW2"] as? String)
        let mw3Value: String? = (context.metadata["MW3"] as? String)
        XCTAssertEqual(mw1Value, "value1")
        XCTAssertEqual(mw2Value, "value2")
        XCTAssertEqual(mw3Value, "value3")
    }
}

// MARK: - Test Middleware

private struct ContextModifyingMiddleware: Middleware {
    let key: String
    let value: String
    let priority = ExecutionPriority.custom
    
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result {
        // Set value in context based on key name
        context.metadata[key] = value
        
        // Don't call next for side effects
        throw ParallelExecutionError.middlewareShouldNotCallNext
    }
}
