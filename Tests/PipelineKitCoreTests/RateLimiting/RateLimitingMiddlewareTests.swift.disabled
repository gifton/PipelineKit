import XCTest
@testable import PipelineKitCore
import PipelineKitTestSupport

final class RateLimitingMiddlewareTests: XCTestCase {

    // MARK: - Test Commands

    struct TestCommand: Command {
        typealias Result = String
        let id: Int

        func execute() async throws -> String {
            "Command \(id) executed"
        }
    }

    struct PriorityCommand: Command, PriorityAware {
        typealias Result = String
        let id: Int
        let priority: Priority

        func execute() async throws -> String {
            "Priority command \(id) executed"
        }
    }

    // MARK: - Tests

    func testTokenBucketStrategy() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .tokenBucket(capacity: 3, refillRate: 1.0),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        // When - consume all tokens
        for i in 0..<3 {
            let result = try await middleware.execute(
                TestCommand(id: i),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTAssertEqual(result, "Command \(i) executed")
        }

        // Then - next request should be rate limited
        do {
            _ = try await middleware.execute(
                TestCommand(id: 3),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit error")
        } catch {
            if case PipelineError.rateLimitExceeded = error {
                // Expected
            } else {
                XCTFail("Unexpected error: \(error)")
            }
        }

        // Wait for token refill
        try await Task.sleep(nanoseconds: 1_100_000_000) // 1.1 seconds

        // Should be able to execute again
        let result = try await middleware.execute(
            TestCommand(id: 4),
            context: CommandContext()
        ) { cmd, _ in
            try await cmd.execute()
        }
        XCTAssertEqual(result, "Command 4 executed")
    }

    func testSlidingWindowStrategy() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .slidingWindow(windowSize: 1.0, maxRequests: 3),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        // When - execute 3 requests
        for i in 0..<3 {
            _ = try await middleware.execute(
                TestCommand(id: i),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
        }

        // Then - 4th request should be limited
        do {
            _ = try await middleware.execute(
                TestCommand(id: 3),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit error")
        } catch {
            XCTAssertTrue(error is PipelineError)
        }

        // Wait for window to slide
        try await Task.sleep(nanoseconds: 1_100_000_000)

        // Should work again
        _ = try await middleware.execute(
            TestCommand(id: 4),
            context: CommandContext()
        ) { cmd, _ in
            try await cmd.execute()
        }
    }

    func testFixedWindowStrategy() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .fixedWindow(windowSize: 1.0, maxRequests: 2),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        // When - execute 2 requests
        for i in 0..<2 {
            _ = try await middleware.execute(
                TestCommand(id: i),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
        }

        // Then - 3rd request in same window should fail
        do {
            _ = try await middleware.execute(
                TestCommand(id: 2),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit error")
        } catch {
            XCTAssertTrue(error is PipelineError)
        }
    }

    func testLeakyBucketStrategy() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .leakyBucket(capacity: 3, leakRate: 0.1), // Leak every 100ms
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter
        )

        // When - fill the bucket
        for i in 0..<3 {
            _ = try await middleware.execute(
                TestCommand(id: i),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
        }

        // Bucket should be full
        do {
            _ = try await middleware.execute(
                TestCommand(id: 3),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit error")
        } catch {
            XCTAssertTrue(error is PipelineError)
        }

        // Wait for leak
        try await Task.sleep(nanoseconds: 150_000_000) // 150ms

        // Should have room for one more
        _ = try await middleware.execute(
            TestCommand(id: 4),
            context: CommandContext()
        ) { cmd, _ in
            try await cmd.execute()
        }
    }

    func testAdaptiveStrategy() async throws {
        // Given
        var currentLoad = 0.3
        let limiter = RateLimiter(
            strategy: .adaptive(
                baseRate: 10,
                loadFactor: { currentLoad }
            ),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        // When load is low (0.3), should allow more requests
        let allowedAtLowLoad = await countAllowedRequests(
            middleware: middleware,
            count: 15
        )

        // Increase load
        currentLoad = 0.9

        // When load is high, should allow fewer requests
        let allowedAtHighLoad = await countAllowedRequests(
            middleware: middleware,
            count: 15
        )

        // Then
        XCTAssertGreaterThan(allowedAtLowLoad, allowedAtHighLoad)
    }

    func testPriorityBasedStrategy() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .priorityBased(limits: [
                .low: RateLimitConfig(maxRequests: 1, windowSize: 1.0),
                .medium: RateLimitConfig(maxRequests: 2, windowSize: 1.0),
                .high: RateLimitConfig(maxRequests: 3, windowSize: 1.0),
                .critical: RateLimitConfig(maxRequests: 5, windowSize: 1.0)
            ]),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        // When - test different priorities

        // Low priority - should allow 1
        _ = try await middleware.execute(
            PriorityCommand(id: 1, priority: .low),
            context: CommandContext()
        ) { cmd, _ in
            try await cmd.execute()
        }

        // Second low priority should fail
        do {
            _ = try await middleware.execute(
                PriorityCommand(id: 2, priority: .low),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit")
        } catch {
            XCTAssertTrue(error is PipelineError)
        }

        // High priority should still work
        for i in 0..<3 {
            _ = try await middleware.execute(
                PriorityCommand(id: 10 + i, priority: .high),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
        }
    }

    func testRateLimitBypassForAllowedCommands() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .tokenBucket(capacity: 1, refillRate: 0.1),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        // When - consume the token
        _ = try await middleware.execute(
            TestCommand(id: 1),
            context: CommandContext()
        ) { cmd, _ in
            try await cmd.execute()
        }

        // Regular command should be rate limited
        do {
            _ = try await middleware.execute(
                TestCommand(id: 2),
                context: CommandContext()
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit")
        } catch {
            XCTAssertTrue(error is PipelineError)
        }

        // Note: The current API doesn't support command-specific bypassing
        // This test is modified to test basic rate limiting only
    }

    func testKeyExtractor() async throws {
        // Given - rate limit per user
        let limiter = RateLimiter(
            strategy: .tokenBucket(capacity: 2, refillRate: 1.0),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(
            limiter: limiter,
            identifierExtractor: { _, context in
                let metadata = context.commandMetadata
                return metadata.userId ?? "anonymous"
            }
        )

        // When - execute requests for different users
        let metadata1 = TestCommandMetadata(userId: "user1")
        let context1 = CommandContext(metadata: metadata1)

        let metadata2 = TestCommandMetadata(userId: "user2")
        let context2 = CommandContext(metadata: metadata2)

        // User 1 can make 2 requests
        for i in 0..<2 {
            _ = try await middleware.execute(
                TestCommand(id: i),
                context: context1
            ) { cmd, _ in
                try await cmd.execute()
            }
        }

        // User 2 can also make 2 requests
        for i in 0..<2 {
            _ = try await middleware.execute(
                TestCommand(id: i),
                context: context2
            ) { cmd, _ in
                try await cmd.execute()
            }
        }

        // User 1's 3rd request should fail
        do {
            _ = try await middleware.execute(
                TestCommand(id: 3),
                context: context1
            ) { cmd, _ in
                try await cmd.execute()
            }
            XCTFail("Expected rate limit")
        } catch {
            XCTAssertTrue(error is PipelineError)
        }
    }

    func testMetricsEmission() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .tokenBucket(capacity: 2, refillRate: 1.0),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        let context = CommandContext()

        // When - successful request
        _ = try await middleware.execute(
            TestCommand(id: 1),
            context: context
        ) { cmd, _ in
            try await cmd.execute()
        }

        // Then
        XCTAssertEqual(context.metrics["rateLimit.allowed"] as? Bool, true)
        XCTAssertNotNil(context.metrics["rateLimit.strategy"])
        XCTAssertNotNil(context.metrics["rateLimit.key"])
    }

    func testConcurrentRequests() async throws {
        // Given
        let limiter = RateLimiter(
            strategy: .tokenBucket(capacity: 10, refillRate: 0),
            scope: .perUser
        )
        let middleware = RateLimitingMiddleware(limiter: limiter)

        let requestCount = 20

        // When - send concurrent requests
        let results = await withTaskGroup(of: Result<String, Error>.self) { group in
            for i in 0..<requestCount {
                group.addTask {
                    do {
                        let result = try await middleware.execute(
                            TestCommand(id: i),
                            context: CommandContext()
                        ) { cmd, _ in
                            try await cmd.execute()
                        }
                        return .success(result)
                    } catch {
                        return .failure(error)
                    }
                }
            }

            var results: [Result<String, Error>] = []
            for await result in group {
                results.append(result)
            }
            return results
        }

        // Then - exactly 10 should succeed
        let successes = results.filter { if case .success = $0 { return true } else { return false } }
        let failures = results.filter { if case .failure = $0 { return true } else { return false } }

        XCTAssertEqual(successes.count, 10)
        XCTAssertEqual(failures.count, 10)
    }

    // MARK: - Helper Methods

    private func countAllowedRequests(
        middleware: RateLimitingMiddleware,
        count: Int
    ) async -> Int {
        var allowed = 0

        for i in 0..<count {
            do {
                _ = try await middleware.execute(
                    TestCommand(id: i),
                    context: CommandContext()
                ) { cmd, _ in
                    try await cmd.execute()
                }
                allowed += 1
            } catch {
                // Rate limited
            }
        }

        return allowed
    }
}

// MARK: - Protocol Conformance

protocol PriorityAware {
    var priority: Priority { get }
}

