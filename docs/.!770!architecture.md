# PipelineKit Architecture

This document provides an in-depth look at PipelineKit's architecture, design decisions, and implementation details.

## Overview

PipelineKit implements the Chain of Responsibility pattern with a focus on:
- **Type Safety**: Strongly-typed commands and results
- **Performance**: Optimized execution paths and minimal overhead
- **Concurrency**: Thread-safe operations with modern Swift concurrency
- **Flexibility**: Composable middleware and extensible design

## Core Components

### 1. Command

Commands encapsulate requests with strongly-typed results:

```swift
public protocol Command: Sendable {
    associatedtype Result: Sendable
}
```

**Design Decisions:**
- `Sendable` conformance ensures thread safety
- Associated type `Result` provides type-safe return values
- No base class to avoid inheritance overhead

### 2. CommandHandler

Handlers process commands and return results:

```swift
public protocol CommandHandler: Sendable {
    associatedtype CommandType: Command
    func handle(_ command: CommandType) async throws -> CommandType.Result
}
```

**Design Decisions:**
- Single responsibility: one handler per command type
- Async/await support for modern concurrency
- Throws for explicit error handling

### 3. CommandContext

Thread-safe storage for sharing data between middleware:

```swift
public final class CommandContext: @unchecked Sendable {
    private var storage: [ObjectIdentifier: Any] = [:]
    private let lock = NSLock()
    
    public func get<Key: ContextKey>(_ key: Key.Type) -> Key.Value?
    public func set<T>(_ value: T, for key: any ContextKey.Type)
}
```

**Performance Optimization:**
- Changed from actor to class with NSLock (94% performance improvement)
- Direct synchronous access without async overhead
- Efficient key-value storage using ObjectIdentifier

### 4. Middleware

Intercepts and modifies command execution:

```swift
public protocol Middleware: Sendable {
    var priority: ExecutionPriority { get }
    
    func execute<T: Command>(
        _ command: T,
        context: CommandContext,
        next: @Sendable (T, CommandContext) async throws -> T.Result
    ) async throws -> T.Result
}
```

**Design Features:**
- Priority-based execution order
- Generic over command types
- Access to both command and context
- Continuation-style for flexible control flow

### 5. Pipeline

Orchestrates command execution through middleware:

```swift
public protocol Pipeline: Sendable {
    associatedtype H: CommandHandler
    func execute<T>(_ command: T, context: CommandContext) async throws -> T.Result
        where T: Command, T == H.CommandType
}
```

## Execution Flow

```
